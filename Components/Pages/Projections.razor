@page "/projections"
@rendermode InteractiveServer
@inject IWebHostEnvironment Env

<h1>Projections</h1>
<p class="sub">Predict future spendings based on your transaction history</p>

@if (!string.IsNullOrWhiteSpace(ErrorMessage))
{
    <div class="error-banner">@ErrorMessage</div>
}

@if (AllTransactions.Count == 0)
{
    <div class="card empty">
        <p>No transactions found.</p>
        <p class="muted">Upload CSV files on the <a href="/">Home</a> page to generate projections.</p>
    </div>
}
else
{
    <div class="card controls-card">
        <div class="controls-row">
            <div class="controls-left">
                <span class="interval-label">Interval</span>
                @foreach (var iv in Intervals)
                {
                    <button class="tool @(SelectedInterval == iv.Key ? "active" : "")"
                            @onclick="() => SetInterval(iv.Key)">
                        @iv.Value
                    </button>
                }
            </div>
            <div class="controls-right">
                <span class="interval-label">Periods ahead</span>
                <input type="number" min="1" @bind="PeriodsInput" class="periods-input" />
                <span class="range-value">@IntervalLabel@(PeriodsInput != 1 ? "s" : "")</span>
                <button class="tool calculate-btn" @onclick="Calculate">
                    <svg viewBox="0 0 24 24"><path d="M5 3l14 9-14 9V3z" /></svg>
                    Calculate
                </button>
            </div>
        </div>
        <div class="mode-row">
            <span class="interval-label">Mode</span>
            <button class="tool mode-btn @(SelectedMode == "all" ? "active" : "")" @onclick='() => SetMode("all")'>
                <svg viewBox="0 0 24 24"><path d="M3 3v18h18M7 16l4-4 4 4 5-6" /></svg>
                All Spendings
            </button>
            <button class="tool mode-btn @(SelectedMode == "smart" ? "active" : "")" @onclick='() => SetMode("smart")'>
                <svg viewBox="0 0 24 24"><path d="M3 12a9 9 0 1 0 3-6.7M3 4v5h5" /></svg>
                Sub-Aware
            </button>
            <button class="tool mode-btn @(SelectedMode == "subonly" ? "active" : "")" @onclick='() => SetMode("subonly")'>
                <svg viewBox="0 0 24 24"><path d="M12 8v4l3 3M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0z" /></svg>
                Sub-Only
            </button>
            <span class="mode-hint">@ModeHint</span>
        </div>
    </div>

    <div class="card chart-card">
        <div class="card-head">
            <span>Spending Projection</span>
            <div class="card-head-pills">
                <span class="pill mode-pill @SelectedMode">@ModeLabel</span>
                <span class="pill projection-pill">@PeriodsAhead @IntervalLabel@(PeriodsAhead != 1 ? "s" : "") ahead</span>
            </div>
        </div>
        <div class="chart-area">
            @{
                RenderChart();
            }
            <svg viewBox="0 0 @ChartWidth @ChartHeight" class="chart-svg" xmlns="http://www.w3.org/2000/svg">
                @foreach (var gl in GridLines)
                {
                    <line x1="@P(ChartPadLeft)" y1="@P(gl.Y)" x2="@P(ChartWidth - ChartPadRight)" y2="@P(gl.Y)"
                          stroke="rgba(255,255,255,0.06)" stroke-width="1" />
                    @((MarkupString)$"<text x=\"{P(ChartPadLeft - 8)}\" y=\"{P(gl.Y + 4)}\" fill=\"#888\" font-size=\"11\" text-anchor=\"end\" font-family=\"ui-monospace,monospace\">{gl.Label}</text>")
                }

                @foreach (var xl in XLabels)
                {
                    @((MarkupString)$"<text x=\"{P(xl.X)}\" y=\"{P(ChartHeight - 4)}\" fill=\"#888\" font-size=\"10\" text-anchor=\"middle\" font-family=\"ui-monospace,monospace\">{xl.Label}</text>")
                }

                @if (DividerX > 0)
                {
                    <line x1="@P(DividerX)" y1="@P(ChartPadTop)" x2="@P(DividerX)" y2="@P(ChartHeight - ChartPadBottom)"
                          stroke="rgba(255,255,255,0.15)" stroke-width="1" stroke-dasharray="6,4" />
                    @((MarkupString)$"<text x=\"{P(DividerX - 6)}\" y=\"{P(ChartPadTop + 14)}\" fill=\"#666\" font-size=\"10\" text-anchor=\"end\" font-family=\"system-ui\">Historical</text>")
                    @((MarkupString)$"<text x=\"{P(DividerX + 6)}\" y=\"{P(ChartPadTop + 14)}\" fill=\"#666\" font-size=\"10\" text-anchor=\"start\" font-family=\"system-ui\">Projected</text>")
                }

                @if (ShowHistorical && !string.IsNullOrEmpty(HistoricalAreaPath))
                {
                    <path d="@HistoricalAreaPath" fill="rgba(224,92,92,0.08)" />
                }

                @if (ShowProjected && !string.IsNullOrEmpty(ProjectedAreaPath))
                {
                    <path d="@ProjectedAreaPath" fill="rgba(122,162,247,0.08)" />
                }

                @if (ShowExclusion && !string.IsNullOrEmpty(ExclusionAreaPath))
                {
                    <path d="@ExclusionAreaPath" fill="rgba(224,169,62,0.06)" />
                }

                @if (ShowHistorical && !string.IsNullOrEmpty(HistoricalLinePath))
                {
                    <path d="@HistoricalLinePath" fill="none" stroke="#e05c5c" stroke-width="2"
                          stroke-linecap="round" stroke-linejoin="round" class="chart-line historical-line" />
                }

                @if (ShowProjected && !string.IsNullOrEmpty(ProjectedLinePath))
                {
                    <path d="@ProjectedLinePath" fill="none" stroke="#7aa2f7" stroke-width="2"
                          stroke-dasharray="6,4" stroke-linecap="round" stroke-linejoin="round" class="chart-line projected-line" />
                }

                @if (ShowExclusion && !string.IsNullOrEmpty(ExclusionLinePath))
                {
                    <path d="@ExclusionLinePath" fill="none" stroke="#e0a93e" stroke-width="1.5"
                          stroke-dasharray="4,4" stroke-linecap="round" stroke-linejoin="round" />
                }

                @if (ShowExclusion)
                {
                    @for (int i = 0; i < ExclusionPoints.Count && i < ExclusionBuckets.Count; i++)
                    {
                        var idx = i;
                        var pt = ExclusionPoints[idx];
                        var info = ExclusionBuckets[idx];
                        var isVisible = (ActiveExclusionTooltipIndex == idx) || (HoveredExclusionIndex == idx && PinnedExclusionIndex != idx);
                        var isPinned = PinnedExclusionIndex == idx;
                        <g class="chart-point-group"
                           @onmouseenter="() => OnExclusionPointEnter(idx)"
                           @onmouseleave="() => OnExclusionPointLeave(idx)"
                           @onclick="() => OnExclusionPointClick(idx)"
                           style="cursor:pointer">
                            <circle cx="@P(pt.X)" cy="@P(pt.Y)" r="14" fill="transparent" />
                            <circle cx="@P(pt.X)" cy="@P(pt.Y)" r="3.5" fill="#e0a93e" />
                            @if (isVisible || isPinned)
                            {
                                <circle cx="@P(pt.X)" cy="@P(pt.Y)" r="6" fill="rgba(224,169,62,0.3)" stroke="#e0a93e" stroke-width="1.5" />
                            }
                        </g>
                        @if (isVisible || isPinned)
                        {
                            var tp = TooltipPos(pt.X, pt.Y);
                            @((MarkupString)$"<g><rect x=\"{P(tp.rx)}\" y=\"{P(tp.ry)}\" width=\"112\" height=\"36\" rx=\"8\" fill=\"#1a1a1a\" stroke=\"{(isPinned ? "rgba(224,169,62,0.4)" : "rgba(255,255,255,0.15)")}\" stroke-width=\"{(isPinned ? "1.5" : "1")}\" /><text x=\"{P(tp.tx)}\" y=\"{P(tp.t1y)}\" fill=\"#e0a93e\" font-size=\"12\" font-weight=\"600\" text-anchor=\"middle\" font-family=\"ui-monospace,monospace\">{FormatInMain(info.Value)}</text><text x=\"{P(tp.tx)}\" y=\"{P(tp.t2y)}\" fill=\"#aaa\" font-size=\"10\" text-anchor=\"middle\" font-family=\"ui-monospace,monospace\">{info.Label}</text></g>")
                        }
                    }
                }

                @if (ShowHistorical)
                {
                    @for (int i = 0; i < HistoricalPoints.Count; i++)
                    {
                        var idx = i;
                        var pt = HistoricalPoints[idx];
                        var info = HistoricalBuckets[idx];
                        var isVisible = (ActiveTooltipIndex == idx) || (HoveredPointIndex == idx && PinnedPointIndex != idx);
                        var isPinned = PinnedPointIndex == idx;
                        <g class="chart-point-group"
                           @onmouseenter="() => OnPointEnter(idx)"
                           @onmouseleave="() => OnPointLeave(idx)"
                           @onclick="() => OnPointClick(idx)"
                           style="cursor:pointer">
                            <circle cx="@P(pt.X)" cy="@P(pt.Y)" r="14" fill="transparent" />
                            <circle cx="@P(pt.X)" cy="@P(pt.Y)" r="3.5" fill="#e05c5c" />
                            @if (isVisible || isPinned)
                            {
                                <circle cx="@P(pt.X)" cy="@P(pt.Y)" r="6" fill="rgba(224,92,92,0.3)" stroke="#e05c5c" stroke-width="1.5" />
                            }
                        </g>
                        @if (isVisible || isPinned)
                        {
                            var tp = TooltipPos(pt.X, pt.Y);
                            @((MarkupString)$"<g><rect x=\"{P(tp.rx)}\" y=\"{P(tp.ry)}\" width=\"112\" height=\"36\" rx=\"8\" fill=\"#1a1a1a\" stroke=\"{(isPinned ? "rgba(224,92,92,0.4)" : "rgba(255,255,255,0.15)")}\" stroke-width=\"{(isPinned ? "1.5" : "1")}\" /><text x=\"{P(tp.tx)}\" y=\"{P(tp.t1y)}\" fill=\"#e05c5c\" font-size=\"12\" font-weight=\"600\" text-anchor=\"middle\" font-family=\"ui-monospace,monospace\">{FormatInMain(info.Value)}</text><text x=\"{P(tp.tx)}\" y=\"{P(tp.t2y)}\" fill=\"#aaa\" font-size=\"10\" text-anchor=\"middle\" font-family=\"ui-monospace,monospace\">{info.Label}</text></g>")
                        }
                    }
                }

                @if (ShowProjected)
                {
                    @for (int i = 0; i < ProjectedPoints.Count; i++)
                    {
                        var idx = HistoricalPoints.Count + i;
                        var pt = ProjectedPoints[i];
                        var info = ProjectedBuckets[i];
                        var isVisible = (ActiveTooltipIndex == idx) || (HoveredPointIndex == idx && PinnedPointIndex != idx);
                        var isPinned = PinnedPointIndex == idx;
                        <g class="chart-point-group"
                           @onmouseenter="() => OnPointEnter(idx)"
                           @onmouseleave="() => OnPointLeave(idx)"
                           @onclick="() => OnPointClick(idx)"
                           style="cursor:pointer">
                            <circle cx="@P(pt.X)" cy="@P(pt.Y)" r="14" fill="transparent" />
                            <circle cx="@P(pt.X)" cy="@P(pt.Y)" r="3.5" fill="#7aa2f7" stroke="#111" stroke-width="1" />
                            @if (isVisible || isPinned)
                            {
                                <circle cx="@P(pt.X)" cy="@P(pt.Y)" r="6" fill="rgba(122,162,247,0.3)" stroke="#7aa2f7" stroke-width="1.5" />
                            }
                        </g>
                        @if (isVisible || isPinned)
                        {
                            var tp = TooltipPos(pt.X, pt.Y);
                            @((MarkupString)$"<g><rect x=\"{P(tp.rx)}\" y=\"{P(tp.ry)}\" width=\"112\" height=\"36\" rx=\"8\" fill=\"#1a1a1a\" stroke=\"{(isPinned ? "rgba(122,162,247,0.4)" : "rgba(255,255,255,0.15)")}\" stroke-width=\"{(isPinned ? "1.5" : "1")}\" /><text x=\"{P(tp.tx)}\" y=\"{P(tp.t1y)}\" fill=\"#7aa2f7\" font-size=\"12\" font-weight=\"600\" text-anchor=\"middle\" font-family=\"ui-monospace,monospace\">{FormatInMain(info.Value)}</text><text x=\"{P(tp.tx)}\" y=\"{P(tp.t2y)}\" fill=\"#aaa\" font-size=\"10\" text-anchor=\"middle\" font-family=\"ui-monospace,monospace\">{info.Label}</text></g>")
                        }
                    }
                }
            </svg>
        </div>

        <div class="chart-legend">
            <span class="legend-item @(!ShowHistorical ? "inactive" : "")" @onclick="ToggleHistorical"><span class="legend-dot historical-dot @(!ShowHistorical ? "inactive" : "")"></span> Historical</span>
            <span class="legend-item @(!ShowProjected ? "inactive" : "")" @onclick="ToggleProjected"><span class="legend-dot projected-dot @(!ShowProjected ? "inactive" : "")"></span> Projected</span>
            @if (ExclusionPoints.Count > 0)
            {
                <span class="legend-item @(!ShowExclusion ? "inactive" : "")" @onclick="ToggleExclusion"><span class="legend-dot exclusion-dot @(!ShowExclusion ? "inactive" : "")"></span> Without deselected</span>
            }
        </div>
    </div>

    <div class="summary-grid">
        <div class="summary-card">
            <span class="summary-label">Avg / @IntervalLabel</span>
            <span class="summary-value negative">@FormatInMain(AvgPerPeriod)</span>
        </div>
        <div class="summary-card">
            <span class="summary-label">Projected total</span>
            <span class="summary-value negative">@FormatInMain(ProjectedTotal)</span>
        </div>
        <div class="summary-card">
            <span class="summary-label">Companies</span>
            <span class="summary-value muted">@SelectedCompanyCount / @AllCompanies.Count</span>
        </div>
        <div class="summary-card muted-card">
            <span class="summary-label">Data points</span>
            <span class="summary-value muted">@HistoricalBuckets.Count</span>
        </div>
    </div>

    <div class="card filter-card">
        <div class="card-head">
            <span>Companies</span>
            <span class="count">@SelectedCompanyCount</span>
        </div>

        <div class="filter-actions">
            <button class="filter-btn" @onclick="SelectAll">All</button>
            <button class="filter-btn" @onclick="SelectNone">None</button>
        </div>

        <ul class="company-list">
            @foreach (var c in AllCompanies.OrderBy(c => c))
            {
                <li class="company-item @(CompanySelected[c] ? "selected" : "")">
                    <span class="check-box" @onclick="() => ToggleCompany(c)">
                        @if (CompanySelected[c])
                        {
                            <svg viewBox="0 0 24 24"><path d="M5 13l4 4L19 7" /></svg>
                        }
                    </span>
                    <span class="company-name" @onclick="() => ToggleCompany(c)">
                        @c
                        @if (CompanyAnalyses.ContainsKey(c) && CompanyAnalyses[c].Behavior == CompanyBehavior.ActiveSubscription)
                        {
                            <span class="sub-indicator" title="Active subscription">●</span>
                        }
                    </span>
                    @if (CancellationDates.ContainsKey(c))
                    {
                        <span class="cancel-badge">cancels @CancellationDates[c].ToString("MMM dd")</span>
                    }
                    <span class="company-amount negative">@FormatInMain(CompanyTotals[c])</span>
                    <button class="profile-btn" @onclick="() => OpenProfile(c)" title="View details">
                        <svg viewBox="0 0 24 24"><path d="M9 18l6-6-6-6" /></svg>
                    </button>
                </li>
            }
        </ul>
    </div>
}

@if (ProfileCompany is not null)
{
    var profileTxs = AllTransactions
        .Where(t => string.Equals(t.Company, ProfileCompany, StringComparison.OrdinalIgnoreCase))
        .OrderByDescending(t => t.Date)
        .ToList();

    var profileMonths = profileTxs.Select(t => new { t.Date.Year, t.Date.Month }).Distinct().Count();
    var profileTotal = profileTxs.Where(t => t.Amount < 0).Sum(t => ConvertToMain(t.Amount, t.Currency));
    var profileAvg = profileMonths > 0 ? profileTotal / profileMonths : 0m;

    var hasBehavior = CompanyAnalyses.ContainsKey(ProfileCompany);
    var behavior = hasBehavior ? CompanyAnalyses[ProfileCompany].Behavior : CompanyBehavior.Irregular;
    var behaviorLabel = behavior switch
    {
        CompanyBehavior.ActiveSubscription => "Active Subscription",
        CompanyBehavior.RecurringReturner => "Recurring Returner",
        CompanyBehavior.CancelledSubscription => "Cancelled",
        CompanyBehavior.OneOff => "One-Off",
        _ => "Irregular"
    };

    <div class="profile-overlay" @onclick="CloseProfile">
        <div class="profile-panel" @onclick:stopPropagation="true">
            <div class="profile-header">
                <button class="back-btn" @onclick="CloseProfile">
                    <svg viewBox="0 0 24 24"><path d="M19 12H5M5 12l7-7M5 12l7 7" /></svg>
                    Back
                </button>
                <span class="profile-title">@ProfileCompany</span>
                <span class="pill behavior-pill @behavior.ToString().ToLowerInvariant()">@behaviorLabel</span>
            </div>

            <div class="profile-stats">
                <div class="stat-card">
                    <span class="stat-label">Transactions</span>
                    <span class="stat-value">@profileTxs.Count</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">Months Active</span>
                    <span class="stat-value">@profileMonths</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">Total Spent</span>
                    <span class="stat-value negative">@FormatInMain(profileTotal)</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">Avg / Month</span>
                    <span class="stat-value negative">@FormatInMain(profileAvg)</span>
                </div>
            </div>

            @if (behavior == CompanyBehavior.ActiveSubscription || behavior == CompanyBehavior.RecurringReturner)
            {
                <div class="card cancel-card">
                    <div class="card-head">
                        <span>Plan Cancellation</span>
                    </div>
                    @if (CancellationDates.ContainsKey(ProfileCompany))
                    {
                        <div class="cancel-info">
                            <span>Scheduled for <strong>@CancellationDates[ProfileCompany].ToString("yyyy-MM-dd")</strong></span>
                            <button class="filter-btn cancel-remove" @onclick="() => RemoveCancellation(ProfileCompany)">Remove</button>
                        </div>
                    }
                    else
                    {
                        <div class="cancel-form">
                            <span class="cancel-label">Set a cancellation date to exclude this subscription from projections after that date:</span>
                            <div class="cancel-input-row">
                                <input type="date" @bind="CancelDateInput" class="cancel-date-input" />
                                <button class="tool calculate-btn" @onclick="() => SetCancellation(ProfileCompany)">
                                    Set Cancellation
                                </button>
                            </div>
                        </div>
                    }
                </div>
            }

            <div class="card profile-tx-card">
                <div class="card-head">
                    <span>Transactions</span>
                    <span class="count">@profileTxs.Count</span>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Description</th>
                                <th>Payment</th>
                                <th class="r">Amount</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var t in profileTxs)
                            {
                                <tr>
                                    <td class="mono">@t.Date.ToString("yyyy-MM-dd")</td>
                                    <td class="muted">@t.Description</td>
                                    <td>
                                        @if (!string.IsNullOrWhiteSpace(t.PaymentMethod))
                                        {
                                            <span class="pill payment">@t.PaymentMethod</span>
                                        }
                                    </td>
                                    <td class="r mono @(t.Amount < 0 ? "negative" : "positive")">@FormatInMain(ConvertToMain(t.Amount, t.Currency))</td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
}

@code {
    record Tx(DateTime Date, string Company, string Description, string? PaymentMethod, decimal Amount, string Currency, string AccountId, string AccountName);

    readonly List<Tx> AllTransactions = new();
    readonly Dictionary<string, bool> CompanySelected = new();
    readonly Dictionary<string, decimal> CompanyTotals = new();
    readonly List<string> AllCompanies = new();
    string? ErrorMessage;

    string MainCurrency = "EUR";
    readonly Dictionary<string, decimal> CurrencyRates = new()
    {
        ["EUR"] = 1m, ["GBP"] = 1.18m, ["USD"] = 0.92m, ["JPY"] = 0.006m, ["CHF"] = 1.06m
    };

    static readonly Dictionary<string, string> CurrencySymbolMap = new()
    {
        ["GBP"] = "£", ["USD"] = "$", ["EUR"] = "€", ["JPY"] = "¥", ["CHF"] = "CHF "
    };

    string MainCurrencySymbol => CurrencySymbolMap.GetValueOrDefault(MainCurrency, "");

    decimal ConvertToMain(decimal amount, string fromCurrency)
    {
        if (fromCurrency == MainCurrency) return amount;
        var fromRate = CurrencyRates.GetValueOrDefault(fromCurrency, 1m);
        var mainRate = CurrencyRates.GetValueOrDefault(MainCurrency, 1m);
        if (mainRate == 0) mainRate = 1m;
        return amount * fromRate / mainRate;
    }

    string FormatInMain(decimal alreadyConverted)
    {
        var symbol = MainCurrencySymbol;
        var abs = Math.Abs(alreadyConverted).ToString("0.00");
        return alreadyConverted < 0 ? $"-{symbol}{abs}" : $"{symbol}{abs}";
    }

    string? ProfileCompany;
    DateTime CancelDateInput = DateTime.Today.AddMonths(1);
    readonly Dictionary<string, DateTime> CancellationDates = new();

    string SelectedInterval = "month";
    int PeriodsAhead = 6;
    int PeriodsInput = 6;
    string SelectedMode = "all";

    string ModeLabel => SelectedMode switch
    {
        "smart" => "Sub-Aware",
        "subonly" => "Sub-Only",
        _ => "All Spendings"
    };

    string ModeHint => SelectedMode switch
    {
        "smart" => "Subs + irregular trend, excludes cancelled & one-offs",
        "subonly" => "Coming soon — subscriptions only",
        _ => "Trend line across all transactions"
    };

    static readonly Dictionary<string, string> Intervals = new()
    {
        ["week"] = "Weeks",
        ["month"] = "Months",
        ["year"] = "Years"
    };

    string IntervalLabel => SelectedInterval switch
    {
        "week" => "week",
        "year" => "year",
        _ => "month"
    };

    int SelectedCompanyCount => CompanySelected.Count(c => c.Value);

    const int ChartWidth = 800;
    const int ChartHeight = 340;
    const int ChartPadTop = 30;
    const int ChartPadBottom = 28;
    const int ChartPadLeft = 62;
    const int ChartPadRight = 16;

    List<(string Label, decimal Value)> HistoricalBuckets = new();
    List<(string Label, decimal Value)> ProjectedBuckets = new();
    List<(double X, double Y)> HistoricalPoints = new();
    List<(double X, double Y)> ProjectedPoints = new();
    List<(double Y, string Label)> GridLines = new();
    List<(double X, string Label)> XLabels = new();
    string HistoricalLinePath = "";
    string ProjectedLinePath = "";
    string HistoricalAreaPath = "";
    string ProjectedAreaPath = "";
    string ExclusionLinePath = "";
    string ExclusionAreaPath = "";
    List<(double X, double Y)> ExclusionPoints = new();
    List<(string Label, decimal Value)> ExclusionBuckets = new();
    double DividerX;
    decimal AvgPerPeriod;
    decimal ProjectedTotal;

    int? HoveredPointIndex;
    int? PinnedPointIndex;
    int? ActiveTooltipIndex => PinnedPointIndex ?? HoveredPointIndex;

    int? HoveredExclusionIndex;
    int? PinnedExclusionIndex;
    int? ActiveExclusionTooltipIndex => PinnedExclusionIndex ?? HoveredExclusionIndex;

    bool ShowHistorical = true;
    bool ShowProjected = true;
    bool ShowExclusion = true;

    void OnPointEnter(int index) => HoveredPointIndex = index;

    void OnPointLeave(int index)
    {
        if (HoveredPointIndex == index)
            HoveredPointIndex = null;
    }

    void OnPointClick(int index)
    {
        if (PinnedPointIndex == index)
            PinnedPointIndex = null;
        else
            PinnedPointIndex = index;
    }

    void OnExclusionPointEnter(int index) => HoveredExclusionIndex = index;

    void OnExclusionPointLeave(int index)
    {
        if (HoveredExclusionIndex == index)
            HoveredExclusionIndex = null;
    }

    void OnExclusionPointClick(int index)
    {
        if (PinnedExclusionIndex == index)
            PinnedExclusionIndex = null;
        else
            PinnedExclusionIndex = index;
    }

    void ToggleHistorical() => ShowHistorical = !ShowHistorical;
    void ToggleProjected() => ShowProjected = !ShowProjected;
    void ToggleExclusion() => ShowExclusion = !ShowExclusion;

    static readonly HashSet<string> PaymentProcessors = new(StringComparer.OrdinalIgnoreCase)
    {
        "PAYPAL","STRIPE","SQUARE","KLARNA","AFTERPAY","CLEARPAY","VENMO",
        "APPLE PAY","APPLEPAY","GOOGLE PAY","GOOGLEPAY","SAMSUNG PAY",
        "VISA","MASTERCARD","AMEX","AMERICAN EXPRESS",
        "REVOLUT","WISE","TRANSFERWISE","SKRILL","NETELLER",
        "CASH APP","CASHAPP","ZELLE","WORLDPAY","ADYEN","CHECKOUT"
    };

    static readonly HashSet<string> KnownCompanies = new(StringComparer.OrdinalIgnoreCase)
    {
        "NETFLIX","SPOTIFY","APPLE","APPLE MUSIC","YOUTUBE","YOUTUBE PREMIUM",
        "DISNEY","DISNEY+","DISNEYPLUS","HBO","HBO MAX","HULU","PRIME VIDEO",
        "AMAZON PRIME","PARAMOUNT","PEACOCK","CRUNCHYROLL","TWITCH","DAZN",
        "AMAZON","EBAY","ETSY","ALIEXPRESS","ALIBABA","WISH","SHEIN",
        "WALMART","TARGET","COSTCO","IKEA","WAYFAIR","BEST BUY","BESTBUY",
        "HOME DEPOT","LOWES","MACYS","NORDSTROM","ZARA","H&M","HM",
        "UNIQLO","GAP","ASOS","BOOHOO","PRIMARK","NEXT","MARKS SPENCER",
        "TESCO","SAINSBURYS","ASDA","MORRISONS","ALDI","LIDL","WAITROSE",
        "ARGOS","CURRYS","JOHN LEWIS","BOOTS","SUPERDRUG",
        "UBER EATS","UBEREATS","DELIVEROO","DOORDASH","GRUBHUB","JUST EAT",
        "JUSTEAT","POSTMATES","INSTACART","GOPUFF",
        "MCDONALDS","BURGER KING","WENDYS","KFC","SUBWAY","DOMINOS",
        "PIZZA HUT","PAPA JOHNS","CHIPOTLE","TACO BELL","FIVE GUYS",
        "NANDOS","GREGGS","PRET","PRET A MANGER","COSTA","STARBUCKS",
        "DUNKIN","TIM HORTONS","KRISPY KREME",
        "GOOGLE","MICROSOFT","ADOBE","DROPBOX","SLACK","ZOOM","NOTION",
        "GITHUB","GITLAB","ATLASSIAN","JIRA","CONFLUENCE","TRELLO",
        "CANVA","FIGMA","SKETCH","INVISION","MIRO",
        "OPENAI","CHATGPT","MIDJOURNEY","ANTHROPIC",
        "AWS","AZURE","DIGITALOCEAN","HEROKU","VERCEL","NETLIFY",
        "GODADDY","NAMECHEAP","CLOUDFLARE","SQUARESPACE","WIX","SHOPIFY",
        "WORDPRESS","HOSTINGER","BLUEHOST","SITEGROUND",
        "STEAM","XBOX","PLAYSTATION","NINTENDO","EPIC GAMES","EPICGAMES",
        "RIOT GAMES","RIOTGAMES","BLIZZARD","EA","ELECTRONIC ARTS","UBISOFT",
        "ROBLOX","MOJANG","MINECRAFT",
        "COURSERA","UDEMY","SKILLSHARE","MASTERCLASS","LINKEDIN LEARNING",
        "PLURALSIGHT","CODECADEMY","TREEHOUSE","BRILLIANT","DUOLINGO",
        "AUDIBLE","KINDLE","SCRIBD","BLINKIST",
        "UBER","LYFT","BOLT","GRAB","DIDI","CABIFY","FREENOW",
        "AIRBNB","BOOKING","BOOKING.COM","EXPEDIA","HOTELS.COM","TRIVAGO",
        "SKYSCANNER","KAYAK","TRAINLINE","NATIONAL RAIL","TFL",
        "RYANAIR","EASYJET","BRITISH AIRWAYS","DELTA","UNITED","SOUTHWEST",
        "HERTZ","AVIS","ENTERPRISE","SIXT","EUROPCAR",
        "PELOTON","STRAVA","MYFITNESSPAL","HEADSPACE","CALM","FITBIT",
        "NIKE","ADIDAS","UNDER ARMOUR","PUMA","REEBOK","GYM","PUREGYM",
        "DAVID LLOYD","VIRGIN ACTIVE","ANYTIME FITNESS","PLANET FITNESS",
        "PATREON","ONLYFANS","SUBSTACK","MEDIUM","GUMROAD",
        "EXPERIAN","EQUIFAX","CREDIT KARMA","CLEARSCORE",
        "VODAFONE","EE","O2","THREE","BT","SKY","VIRGIN MEDIA",
        "VERIZON","ATT","T-MOBILE","SPRINT","COMCAST","XFINITY",
        "BRITISH GAS","OCTOPUS ENERGY","BULB","EON","EDF","SSE","SCOTTISH POWER"
    };

    protected override void OnInitialized()
    {
        LoadCurrencySettings();
        LoadTransactionsFromCsv();
        AnalyzeCompanyBehaviors();
        BuildCompanyList();
        Recalculate();
    }

    void LoadCurrencySettings()
    {
        var settingsPath = Path.Combine(Env.ContentRootPath, "App_Data", "settings.meta");
        if (!File.Exists(settingsPath)) return;

        foreach (var line in File.ReadAllLines(settingsPath))
        {
            var sep = line.IndexOf('=');
            if (sep < 0) continue;
            var key = line[..sep].Trim();
            var val = line[(sep + 1)..].Trim();

            if (key == "maincurrency")
            {
                MainCurrency = val;
            }
            else if (key.StartsWith("rate_"))
            {
                var cur = key[5..];
                if (decimal.TryParse(val, System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out var rate))
                {
                    CurrencyRates[cur] = rate;
                }
            }
        }
    }

    void SetInterval(string interval)
    {
        SelectedInterval = interval;
    }

    void SetMode(string mode)
    {
        SelectedMode = mode;
        Recalculate();
    }

    void Calculate()
    {
        PeriodsAhead = Math.Max(1, PeriodsInput);
        PeriodsInput = PeriodsAhead;
        Recalculate();
    }

    void ToggleCompany(string company)
    {
        CompanySelected[company] = !CompanySelected[company];
        Recalculate();
    }

    void SelectAll()
    {
        foreach (var c in AllCompanies) CompanySelected[c] = true;
        Recalculate();
    }

    void SelectNone()
    {
        foreach (var c in AllCompanies) CompanySelected[c] = false;
        Recalculate();
    }

    void OpenProfile(string company)
    {
        ProfileCompany = company;
        CancelDateInput = DateTime.Today.AddMonths(1);
    }

    void CloseProfile() => ProfileCompany = null;

    void SetCancellation(string company)
    {
        if (CancelDateInput > DateTime.Today)
        {
            CancellationDates[company] = CancelDateInput;
            Recalculate();
        }
    }

    void RemoveCancellation(string company)
    {
        CancellationDates.Remove(company);
        Recalculate();
    }

    void BuildCompanyList()
    {
        AllCompanies.Clear();
        CompanySelected.Clear();
        CompanyTotals.Clear();

        var groups = AllTransactions
            .Where(t => t.Amount < 0)
            .GroupBy(t => t.Company)
            .OrderByDescending(g => Math.Abs(g.Sum(t => ConvertToMain(t.Amount, t.Currency))));

        foreach (var g in groups)
        {
            AllCompanies.Add(g.Key);
            CompanySelected[g.Key] = true;
            CompanyTotals[g.Key] = g.Sum(t => ConvertToMain(t.Amount, t.Currency));
        }
    }

    IEnumerable<Tx> FilteredTransactions =>
        AllTransactions.Where(t => t.Amount < 0 && CompanySelected.ContainsKey(t.Company) && CompanySelected[t.Company]);

    enum CompanyBehavior { ActiveSubscription, RecurringReturner, CancelledSubscription, OneOff, Irregular }

    record CompanyAnalysis(string Company, CompanyBehavior Behavior, decimal TypicalAmount, int DistinctMonths, int MonthsSinceLastCharge, decimal ProjectionWeight);

    readonly Dictionary<string, CompanyAnalysis> CompanyAnalyses = new();

    void AnalyzeCompanyBehaviors()
    {
        CompanyAnalyses.Clear();

        var now = AllTransactions.Count > 0 ? AllTransactions.Max(t => t.Date) : DateTime.UtcNow;
        var lastMonthKey = $"{now.Year}-{now.Month:D2}";
        var nowMonth = new DateTime(now.Year, now.Month, 1);

        var companyGroups = AllTransactions
            .Where(t => t.Amount < 0)
            .GroupBy(t => t.Company, StringComparer.OrdinalIgnoreCase);

        foreach (var g in companyGroups)
        {
            var sortedDates = g.Select(t => t.Date.Date).Distinct().OrderBy(d => d).ToList();
            var distinctMonths = g.Select(t => $"{t.Date.Year}-{t.Date.Month:D2}").Distinct().OrderBy(m => m).ToList();

            var amounts = g.Select(t => Math.Round(ConvertToMain(t.Amount, t.Currency), 2)).ToList();
            var amountGroups = amounts.GroupBy(a => a).OrderByDescending(x => x.Count()).ToList();
            var typicalAmount = amountGroups.First().Key;
            var mostCommonCount = amountGroups.First().Count();
            decimal amountConsistency = (decimal)mostCommonCount / amounts.Count;

            var stdDev = 0.0;
            if (amounts.Count > 1)
            {
                var avg = (double)amounts.Average();
                stdDev = Math.Sqrt(amounts.Select(a => Math.Pow((double)a - avg, 2)).Average());
            }
            var coeffOfVariation = amounts.Average() != 0 ? (decimal)stdDev / Math.Abs(amounts.Average()) : 0;
            bool hasConsistentAmount = amountConsistency >= 0.5m || coeffOfVariation < 0.3m;

            var lastChargeDate = sortedDates.Last();
            var lastChargeMonth = new DateTime(lastChargeDate.Year, lastChargeDate.Month, 1);
            int monthsSinceLast = ((nowMonth.Year - lastChargeMonth.Year) * 12) + nowMonth.Month - lastChargeMonth.Month;

            if (distinctMonths.Count < 2)
            {
                CompanyAnalyses[g.Key] = new CompanyAnalysis(g.Key, CompanyBehavior.OneOff, typicalAmount, distinctMonths.Count, monthsSinceLast, 0m);
                continue;
            }

            var gaps = new List<double>();
            for (int i = 1; i < sortedDates.Count; i++)
                gaps.Add((sortedDates[i] - sortedDates[i - 1]).TotalDays);

            var medianGap = gaps.OrderBy(x => x).ElementAt(gaps.Count / 2);
            bool looksRecurring = medianGap <= 40 && distinctMonths.Count >= 3 && hasConsistentAmount;

            bool chargedRecently = monthsSinceLast <= 1;

            if (looksRecurring && chargedRecently)
            {
                CompanyAnalyses[g.Key] = new CompanyAnalysis(g.Key, CompanyBehavior.ActiveSubscription, typicalAmount, distinctMonths.Count, monthsSinceLast, 1.0m);
                continue;
            }

            if (looksRecurring && !chargedRecently)
            {
                bool hasReturnerPattern = DetectReturnerPattern(distinctMonths);
                if (hasReturnerPattern)
                {
                    decimal weight = CalculateReturnerWeight(monthsSinceLast, distinctMonths.Count);
                    CompanyAnalyses[g.Key] = new CompanyAnalysis(g.Key, CompanyBehavior.RecurringReturner, typicalAmount, distinctMonths.Count, monthsSinceLast, weight);
                }
                else
                {
                    CompanyAnalyses[g.Key] = new CompanyAnalysis(g.Key, CompanyBehavior.CancelledSubscription, typicalAmount, distinctMonths.Count, monthsSinceLast, 0m);
                }
                continue;
            }

            CompanyAnalyses[g.Key] = new CompanyAnalysis(g.Key, CompanyBehavior.Irregular, typicalAmount, distinctMonths.Count, monthsSinceLast, 0m);
        }
    }

    decimal CalculateReturnerWeight(int monthsSinceLast, int distinctMonths)
    {
        decimal recencyDecay;
        if (monthsSinceLast <= 1)
            recencyDecay = 0.20m;
        else if (monthsSinceLast <= 2)
            recencyDecay = 0.12m;
        else if (monthsSinceLast <= 3)
            recencyDecay = 0.08m;
        else if (monthsSinceLast <= 6)
            recencyDecay = 0.04m;
        else
            recencyDecay = 0.01m;

        decimal historyBoost = distinctMonths >= 6 ? 1.2m : distinctMonths >= 4 ? 1.0m : 0.8m;

        return Math.Min(recencyDecay * historyBoost, 0.25m);
    }

    bool DetectReturnerPattern(List<string> sortedMonths)
    {
        if (sortedMonths.Count < 3) return false;

        var monthDates = sortedMonths
            .Select(m => DateTime.ParseExact(m, "yyyy-MM", System.Globalization.CultureInfo.InvariantCulture))
            .ToList();

        int gapCount = 0;
        int streakStartCount = 0;
        bool inStreak = true;

        for (int i = 1; i < monthDates.Count; i++)
        {
            var diff = ((monthDates[i].Year - monthDates[i - 1].Year) * 12) + monthDates[i].Month - monthDates[i - 1].Month;

            if (diff <= 2)
            {
                if (!inStreak)
                {
                    streakStartCount++;
                    inStreak = true;
                }
            }
            else
            {
                if (inStreak)
                {
                    gapCount++;
                    inStreak = false;
                }
            }
        }

        return streakStartCount >= 2 && gapCount >= 1;
    }

    decimal GetSubscriptionProjectionMonthly(DateTime asOfDate, bool filterBySelection = true)
    {
        decimal total = 0;
        foreach (var kvp in CompanyAnalyses)
        {
            if (filterBySelection && (!CompanySelected.ContainsKey(kvp.Key) || !CompanySelected[kvp.Key])) continue;

            if (CancellationDates.TryGetValue(kvp.Key, out var cancelDate) && asOfDate >= cancelDate)
                continue;

            var analysis = kvp.Value;
            if (analysis.Behavior == CompanyBehavior.ActiveSubscription)
                total += analysis.TypicalAmount;
            else if (analysis.Behavior == CompanyBehavior.RecurringReturner)
                total += analysis.TypicalAmount * analysis.ProjectionWeight;
        }
        return total;
    }

    bool IsSubscriptionCompany(string company)
    {
        if (!CompanyAnalyses.ContainsKey(company)) return false;
        var behavior = CompanyAnalyses[company].Behavior;
        return behavior == CompanyBehavior.ActiveSubscription
            || behavior == CompanyBehavior.RecurringReturner;
    }

    void Recalculate()
    {
        HistoricalBuckets.Clear();
        ProjectedBuckets.Clear();
        HistoricalPoints.Clear();
        ProjectedPoints.Clear();
        GridLines.Clear();
        XLabels.Clear();
        HistoricalLinePath = "";
        ProjectedLinePath = "";
        HistoricalAreaPath = "";
        ProjectedAreaPath = "";
        ExclusionLinePath = "";
        ExclusionAreaPath = "";
        ExclusionPoints.Clear();
        ExclusionBuckets.Clear();
        DividerX = 0;
        AvgPerPeriod = 0;
        ProjectedTotal = 0;
        HoveredPointIndex = null;
        PinnedPointIndex = null;
        HoveredExclusionIndex = null;
        PinnedExclusionIndex = null;

        var txs = AllTransactions.Where(t => t.Amount < 0).ToList();
        if (txs.Count == 0) return;

        var grouped = txs
            .GroupBy(t => BucketKey(t.Date))
            .OrderBy(g => g.Key)
            .Select(g => (Label: BucketLabel(g.Key), Value: g.Sum(t => ConvertToMain(t.Amount, t.Currency))))
            .ToList();

        if (grouped.Count == 0) return;

        HistoricalBuckets = grouped;
        AvgPerPeriod = grouped.Average(b => b.Value);

        var lastDate = txs.Max(t => t.Date);

        var monthlyBuckets = txs
            .GroupBy(t => t.Date.ToString("yyyy-MM"))
            .OrderBy(g => g.Key)
            .Select(g => g.Sum(t => ConvertToMain(t.Amount, t.Currency)))
            .ToList();

        int nm = monthlyBuckets.Count;

        double monthlySlope = 0;
        double monthlyIntercept = 0;
        if (nm > 1)
        {
            double sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            for (int i = 0; i < nm; i++)
            {
                double x = i;
                double y = (double)monthlyBuckets[i];
                sumX += x; sumY += y; sumXY += x * y; sumXX += x * x;
            }
            monthlySlope = (nm * sumXY - sumX * sumY) / (nm * sumXX - sumX * sumX);
            monthlyIntercept = (sumY - monthlySlope * sumX) / nm;
        }
        else if (nm == 1)
        {
            monthlyIntercept = (double)monthlyBuckets[0];
        }

        if (SelectedMode == "smart")
        {
            var irregularTxs = txs.Where(t =>
            {
                if (!CompanyAnalyses.ContainsKey(t.Company)) return true;
                var b = CompanyAnalyses[t.Company].Behavior;
                return b == CompanyBehavior.Irregular;
            }).ToList();

            var irregularMonthly = irregularTxs
                .GroupBy(t => t.Date.ToString("yyyy-MM"))
                .OrderBy(g => g.Key)
                .Select(g => g.Sum(t => ConvertToMain(t.Amount, t.Currency)))
                .ToList();

            int ni = irregularMonthly.Count;
            double irregSlope = 0;
            double irregIntercept = 0;
            if (ni > 1)
            {
                double sX = 0, sY = 0, sXY = 0, sXX = 0;
                for (int i = 0; i < ni; i++)
                {
                    double x = i;
                    double y = (double)irregularMonthly[i];
                    sX += x; sY += y; sXY += x * y; sXX += x * x;
                }
                irregSlope = (ni * sXY - sX * sY) / (ni * sXX - sX * sX);
                irregIntercept = (sY - irregSlope * sX) / ni;
            }
            else if (ni == 1)
            {
                irregIntercept = (double)irregularMonthly[0];
            }

            for (int i = 1; i <= PeriodsAhead; i++)
            {
                var futureDate = SelectedInterval switch
                {
                    "week" => lastDate.AddDays(7 * i),
                    "year" => lastDate.AddYears(i),
                    _ => lastDate.AddMonths(i)
                };

                decimal projectedValue;
                if (SelectedInterval == "year")
                {
                    decimal yearTotal = 0;
                    for (int m = 0; m < 12; m++)
                    {
                        var monthDate = futureDate.AddMonths(m - 11);
                        decimal subMonth = GetSubscriptionProjectionMonthly(monthDate, filterBySelection: false);
                        int monthIdx = ni + ((i - 1) * 12) + m;
                        decimal irregMonth = (decimal)(irregIntercept + irregSlope * monthIdx);
                        if (irregMonth > 0) irregMonth = 0;
                        yearTotal += subMonth + irregMonth;
                    }
                    projectedValue = yearTotal;
                }
                else if (SelectedInterval == "week")
                {
                    decimal subWeek = GetSubscriptionProjectionMonthly(futureDate, filterBySelection: false);
                    double monthsFwd = i / 4.33;
                    int monthIdx = ni + (int)Math.Floor(monthsFwd);
                    decimal irregMonth = (decimal)(irregIntercept + irregSlope * monthIdx);
                    if (irregMonth > 0) irregMonth = 0;
                    projectedValue = (subWeek + irregMonth) / 4.33m;
                }
                else
                {
                    decimal subMonth = GetSubscriptionProjectionMonthly(futureDate, filterBySelection: false);
                    int monthIdx = ni + i - 1;
                    decimal irregMonth = (decimal)(irregIntercept + irregSlope * monthIdx);
                    if (irregMonth > 0) irregMonth = 0;
                    projectedValue = subMonth + irregMonth;
                }

                if (projectedValue > 0) projectedValue = 0;
                ProjectedBuckets.Add((BucketLabel(BucketKey(futureDate)), projectedValue));
            }
        }
        else
        {
            for (int i = 1; i <= PeriodsAhead; i++)
            {
                var futureDate = SelectedInterval switch
                {
                    "week" => lastDate.AddDays(7 * i),
                    "year" => lastDate.AddYears(i),
                    _ => lastDate.AddMonths(i)
                };

                decimal projectedValue;
                if (SelectedInterval == "year")
                {
                    decimal yearTotal = 0;
                    for (int m = 0; m < 12; m++)
                    {
                        int monthIdx = nm + ((i - 1) * 12) + m;
                        yearTotal += (decimal)(monthlyIntercept + monthlySlope * monthIdx);
                    }
                    projectedValue = yearTotal;
                }
                else if (SelectedInterval == "week")
                {
                    double monthsFwd = i / 4.33;
                    int monthIdx = nm + (int)Math.Floor(monthsFwd);
                    projectedValue = (decimal)(monthlyIntercept + monthlySlope * monthIdx) / 4.33m;
                }
                else
                {
                    int monthIdx = nm + i - 1;
                    projectedValue = (decimal)(monthlyIntercept + monthlySlope * monthIdx);
                }

                if (projectedValue > 0) projectedValue = 0;
                ProjectedBuckets.Add((BucketLabel(BucketKey(futureDate)), projectedValue));
            }
        }

        ProjectedTotal = ProjectedBuckets.Sum(b => b.Value);

        var allBuckets = HistoricalBuckets.Concat(ProjectedBuckets).ToList();
        int totalPoints = allBuckets.Count;
        if (totalPoints == 0) return;

        var preExclValues = PrecomputeExclusionValues(totalPoints);

        decimal minVal = allBuckets.Min(b => b.Value);
        decimal maxVal = allBuckets.Max(b => b.Value);
        if (preExclValues.Count > 0)
        {
            minVal = Math.Min(minVal, preExclValues.Min());
            maxVal = Math.Max(maxVal, preExclValues.Max());
        }
        decimal range = maxVal - minVal;
        if (range == 0) range = Math.Abs(minVal) > 0 ? Math.Abs(minVal) : 1;

        minVal -= range * 0.1m;
        maxVal += range * 0.1m;
        range = maxVal - minVal;

        double plotW = ChartWidth - ChartPadLeft - ChartPadRight;
        double plotH = ChartHeight - ChartPadTop - ChartPadBottom;

        double MapX(int idx) => ChartPadLeft + (totalPoints > 1 ? (double)idx / (totalPoints - 1) * plotW : plotW / 2);
        double MapY(decimal val) => ChartPadTop + (double)(1 - (val - minVal) / range) * plotH;

        for (int i = 0; i < HistoricalBuckets.Count; i++)
        {
            HistoricalPoints.Add((MapX(i), MapY(HistoricalBuckets[i].Value)));
        }

        int projStart = HistoricalBuckets.Count;
        for (int i = 0; i < ProjectedBuckets.Count; i++)
        {
            ProjectedPoints.Add((MapX(projStart + i), MapY(ProjectedBuckets[i].Value)));
        }

        if (HistoricalBuckets.Count > 0 && ProjectedBuckets.Count > 0)
        {
            DividerX = (MapX(HistoricalBuckets.Count - 1) + MapX(HistoricalBuckets.Count)) / 2;
        }

        HistoricalLinePath = BuildLinePath(HistoricalPoints);

        var projLine = new List<(double X, double Y)>();
        if (HistoricalPoints.Count > 0)
            projLine.Add(HistoricalPoints[^1]);
        projLine.AddRange(ProjectedPoints);
        ProjectedLinePath = BuildLinePath(projLine);

        double baseY = MapY(0) < ChartPadTop ? ChartHeight - ChartPadBottom :
                       MapY(0) > ChartHeight - ChartPadBottom ? ChartHeight - ChartPadBottom :
                       MapY(0);

        HistoricalAreaPath = BuildAreaPath(HistoricalPoints, baseY);
        ProjectedAreaPath = BuildAreaPath(projLine, baseY);

        int gridCount = 5;
        decimal niceStep = NiceGridStep(range, gridCount);
        decimal gridStart = Math.Floor(minVal / niceStep) * niceStep;
        decimal gridEnd = Math.Ceiling(maxVal / niceStep) * niceStep;

        for (decimal val = gridStart; val <= gridEnd; val += niceStep)
        {
            double y = MapY(val);
            if (y >= ChartPadTop - 5 && y <= ChartHeight - ChartPadBottom + 5)
                GridLines.Add((y, FormatAmountWithSymbol(val)));
        }

        int labelStep = Math.Max(1, totalPoints / 8);
        for (int i = 0; i < totalPoints; i += labelStep)
        {
            XLabels.Add((MapX(i), allBuckets[i].Label));
        }
        if (totalPoints > 1 && (totalPoints - 1) % labelStep != 0)
        {
            XLabels.Add((MapX(totalPoints - 1), allBuckets[^1].Label));
        }

        bool hasDeselected = CompanySelected.Any(kvp => !kvp.Value);
        if (hasDeselected && HistoricalBuckets.Count > 0)
        {
            var allSelectedTxs = AllTransactions.Where(t => t.Amount < 0 && CompanySelected.ContainsKey(t.Company) && CompanySelected[t.Company]).ToList();

            var historicalBucketKeys = txs
                .GroupBy(t => BucketKey(t.Date))
                .OrderBy(g => g.Key)
                .Select(g => g.Key)
                .ToList();

            var selectedByBucket = allSelectedTxs
                .GroupBy(t => BucketKey(t.Date))
                .ToDictionary(g => g.Key, g => g.Sum(t => ConvertToMain(t.Amount, t.Currency)));

            var exclHistorical = historicalBucketKeys
                .Select(key => selectedByBucket.TryGetValue(key, out var val) ? val : 0m)
                .ToList();

            var exclMonthly = allSelectedTxs
                .GroupBy(t => t.Date.ToString("yyyy-MM"))
                .OrderBy(g => g.Key)
                .Select(g => g.Sum(t => ConvertToMain(t.Amount, t.Currency)))
                .ToList();

            int enm = exclMonthly.Count;
            double exSlope = 0, exIntercept = 0;
            if (enm > 1)
            {
                double sX = 0, sY = 0, sXY = 0, sXX = 0;
                for (int i = 0; i < enm; i++)
                {
                    double x = i; double y = (double)exclMonthly[i];
                    sX += x; sY += y; sXY += x * y; sXX += x * x;
                }
                exSlope = (enm * sXY - sX * sY) / (enm * sXX - sX * sX);
                exIntercept = (sY - exSlope * sX) / enm;
            }
            else if (enm == 1)
            {
                exIntercept = (double)exclMonthly[0];
            }

            var exclProjected = new List<decimal>();

            if (SelectedMode == "smart")
            {
                var exclIrregularTxs = allSelectedTxs.Where(t =>
                {
                    if (!CompanyAnalyses.ContainsKey(t.Company)) return true;
                    var b = CompanyAnalyses[t.Company].Behavior;
                    return b == CompanyBehavior.Irregular;
                }).ToList();

                var exclIrregularMonthly = exclIrregularTxs
                    .GroupBy(t => t.Date.ToString("yyyy-MM"))
                    .OrderBy(g => g.Key)
                    .Select(g => g.Sum(t => ConvertToMain(t.Amount, t.Currency)))
                    .ToList();

                int eni = exclIrregularMonthly.Count;
                double exIrregSlope = 0, exIrregIntercept = 0;
                if (eni > 1)
                {
                    double sX2 = 0, sY2 = 0, sXY2 = 0, sXX2 = 0;
                    for (int i = 0; i < eni; i++)
                    {
                        double x = i; double y = (double)exclIrregularMonthly[i];
                        sX2 += x; sY2 += y; sXY2 += x * y; sXX2 += x * x;
                    }
                    exIrregSlope = (eni * sXY2 - sX2 * sY2) / (eni * sXX2 - sX2 * sX2);
                    exIrregIntercept = (sY2 - exIrregSlope * sX2) / eni;
                }
                else if (eni == 1)
                {
                    exIrregIntercept = (double)exclIrregularMonthly[0];
                }

                var lastDate2 = txs.Max(t => t.Date);
                for (int i = 1; i <= PeriodsAhead; i++)
                {
                    var futureDate = SelectedInterval switch
                    {
                        "week" => lastDate2.AddDays(7 * i),
                        "year" => lastDate2.AddYears(i),
                        _ => lastDate2.AddMonths(i)
                    };

                    decimal pv;
                    if (SelectedInterval == "year")
                    {
                        decimal yt = 0;
                        for (int m = 0; m < 12; m++)
                        {
                            var monthDate = futureDate.AddMonths(m - 11);
                            decimal subMonth = GetSubscriptionProjectionMonthly(monthDate, filterBySelection: true);
                            int monthIdx = eni + ((i - 1) * 12) + m;
                            decimal irregMonth = (decimal)(exIrregIntercept + exIrregSlope * monthIdx);
                            if (irregMonth > 0) irregMonth = 0;
                            yt += subMonth + irregMonth;
                        }
                        pv = yt;
                    }
                    else if (SelectedInterval == "week")
                    {
                        decimal subWeek = GetSubscriptionProjectionMonthly(futureDate, filterBySelection: true);
                        double monthsFwd = i / 4.33;
                        int monthIdx = eni + (int)Math.Floor(monthsFwd);
                        decimal irregMonth = (decimal)(exIrregIntercept + exIrregSlope * monthIdx);
                        if (irregMonth > 0) irregMonth = 0;
                        pv = (subWeek + irregMonth) / 4.33m;
                    }
                    else
                    {
                        decimal subMonth = GetSubscriptionProjectionMonthly(futureDate, filterBySelection: true);
                        int monthIdx = eni + i - 1;
                        decimal irregMonth = (decimal)(exIrregIntercept + exIrregSlope * monthIdx);
                        if (irregMonth > 0) irregMonth = 0;
                        pv = subMonth + irregMonth;
                    }
                    if (pv > 0) pv = 0;
                    exclProjected.Add(pv);
                }
            }
            else
            {
                for (int i = 1; i <= PeriodsAhead; i++)
                {
                    decimal pv;
                    if (SelectedInterval == "year")
                    {
                        decimal yt = 0;
                        for (int m = 0; m < 12; m++)
                        {
                            int mi = enm + ((i - 1) * 12) + m;
                            yt += (decimal)(exIntercept + exSlope * mi);
                        }
                        pv = yt;
                    }
                    else if (SelectedInterval == "week")
                    {
                        int mi = enm + (int)Math.Floor(i / 4.33);
                        pv = (decimal)(exIntercept + exSlope * mi) / 4.33m;
                    }
                    else
                    {
                        int mi = enm + i - 1;
                        pv = (decimal)(exIntercept + exSlope * mi);
                    }
                    if (pv > 0) pv = 0;
                    exclProjected.Add(pv);
                }
            }

            for (int i = 0; i < exclHistorical.Count && i < HistoricalBuckets.Count; i++)
                ExclusionBuckets.Add((HistoricalBuckets[i].Label, exclHistorical[i]));
            for (int i = 0; i < exclProjected.Count && i < ProjectedBuckets.Count; i++)
                ExclusionBuckets.Add((ProjectedBuckets[i].Label, exclProjected[i]));

            var exclAll = exclHistorical.Concat(exclProjected).ToList();

            for (int i = 0; i < exclAll.Count && i < totalPoints; i++)
                ExclusionPoints.Add((MapX(i), MapY(exclAll[i])));

            ExclusionLinePath = BuildLinePath(ExclusionPoints);

            double exBaseY = MapY(0) < ChartPadTop ? ChartHeight - ChartPadBottom :
                             MapY(0) > ChartHeight - ChartPadBottom ? ChartHeight - ChartPadBottom :
                             MapY(0);
            ExclusionAreaPath = BuildAreaPath(ExclusionPoints, exBaseY);
        }
    }

    List<decimal> PrecomputeExclusionValues(int totalPoints)
    {
        bool hasDeselected = CompanySelected.Any(kvp => !kvp.Value);
        if (!hasDeselected || HistoricalBuckets.Count == 0) return new();

        var txs = AllTransactions.Where(t => t.Amount < 0).ToList();
        var allSelectedTxs = AllTransactions.Where(t => t.Amount < 0 && CompanySelected.ContainsKey(t.Company) && CompanySelected[t.Company]).ToList();

        var historicalBucketKeys = txs
            .GroupBy(t => BucketKey(t.Date))
            .OrderBy(g => g.Key)
            .Select(g => g.Key)
            .ToList();

        var selectedByBucket = allSelectedTxs
            .GroupBy(t => BucketKey(t.Date))
            .ToDictionary(g => g.Key, g => g.Sum(t => ConvertToMain(t.Amount, t.Currency)));

        var exclHistorical = historicalBucketKeys
            .Select(key => selectedByBucket.TryGetValue(key, out var val) ? val : 0m)
            .ToList();

        var exclMonthly = allSelectedTxs
            .GroupBy(t => t.Date.ToString("yyyy-MM"))
            .OrderBy(g => g.Key)
            .Select(g => g.Sum(t => ConvertToMain(t.Amount, t.Currency)))
            .ToList();

        int enm = exclMonthly.Count;
        double exSlope = 0, exIntercept = 0;
        if (enm > 1)
        {
            double sX = 0, sY = 0, sXY = 0, sXX = 0;
            for (int i = 0; i < enm; i++)
            {
                double x = i; double y = (double)exclMonthly[i];
                sX += x; sY += y; sXY += x * y; sXX += x * x;
            }
            exSlope = (enm * sXY - sX * sY) / (enm * sXX - sX * sX);
            exIntercept = (sY - exSlope * sX) / enm;
        }
        else if (enm == 1)
        {
            exIntercept = (double)exclMonthly[0];
        }

        var exclProjected = new List<decimal>();
        var lastDate = txs.Max(t => t.Date);

        if (SelectedMode == "smart")
        {
            var exclIrregularTxs = allSelectedTxs.Where(t =>
            {
                if (!CompanyAnalyses.ContainsKey(t.Company)) return true;
                var b = CompanyAnalyses[t.Company].Behavior;
                return b == CompanyBehavior.Irregular;
            }).ToList();

            var exclIrregularMonthly = exclIrregularTxs
                .GroupBy(t => t.Date.ToString("yyyy-MM"))
                .OrderBy(g => g.Key)
                .Select(g => g.Sum(t => ConvertToMain(t.Amount, t.Currency)))
                .ToList();

            int eni = exclIrregularMonthly.Count;
            double exIrregSlope = 0, exIrregIntercept = 0;
            if (eni > 1)
            {
                double sX2 = 0, sY2 = 0, sXY2 = 0, sXX2 = 0;
                for (int i = 0; i < eni; i++)
                {
                    double x = i; double y = (double)exclIrregularMonthly[i];
                    sX2 += x; sY2 += y; sXY2 += x * y; sXX2 += x * x;
                }
                exIrregSlope = (eni * sXY2 - sX2 * sY2) / (eni * sXX2 - sX2 * sX2);
                exIrregIntercept = (sY2 - exIrregSlope * sX2) / eni;
            }
            else if (eni == 1)
            {
                exIrregIntercept = (double)exclIrregularMonthly[0];
            }

            for (int i = 1; i <= PeriodsAhead; i++)
            {
                var futureDate = SelectedInterval switch
                {
                    "week" => lastDate.AddDays(7 * i),
                    "year" => lastDate.AddYears(i),
                    _ => lastDate.AddMonths(i)
                };
                decimal pv;
                if (SelectedInterval == "year")
                {
                    decimal yt = 0;
                    for (int m = 0; m < 12; m++)
                    {
                        var monthDate = futureDate.AddMonths(m - 11);
                        decimal subMonth = GetSubscriptionProjectionMonthly(monthDate, filterBySelection: true);
                        int monthIdx = eni + ((i - 1) * 12) + m;
                        decimal irregMonth = (decimal)(exIrregIntercept + exIrregSlope * monthIdx);
                        if (irregMonth > 0) irregMonth = 0;
                        yt += subMonth + irregMonth;
                    }
                    pv = yt;
                }
                else if (SelectedInterval == "week")
                {
                    decimal subWeek = GetSubscriptionProjectionMonthly(futureDate, filterBySelection: true);
                    double monthsFwd = i / 4.33;
                    int monthIdx = eni + (int)Math.Floor(monthsFwd);
                    decimal irregMonth = (decimal)(exIrregIntercept + exIrregSlope * monthIdx);
                    if (irregMonth > 0) irregMonth = 0;
                    pv = (subWeek + irregMonth) / 4.33m;
                }
                else
                {
                    decimal subMonth = GetSubscriptionProjectionMonthly(futureDate, filterBySelection: true);
                    int monthIdx = eni + i - 1;
                    decimal irregMonth = (decimal)(exIrregIntercept + exIrregSlope * monthIdx);
                    if (irregMonth > 0) irregMonth = 0;
                    pv = subMonth + irregMonth;
                }
                if (pv > 0) pv = 0;
                exclProjected.Add(pv);
            }
        }
        else
        {
            for (int i = 1; i <= PeriodsAhead; i++)
            {
                decimal pv;
                if (SelectedInterval == "year")
                {
                    decimal yt = 0;
                    for (int m = 0; m < 12; m++)
                    {
                        int mi = enm + ((i - 1) * 12) + m;
                        yt += (decimal)(exIntercept + exSlope * mi);
                    }
                    pv = yt;
                }
                else if (SelectedInterval == "week")
                {
                    int mi = enm + (int)Math.Floor(i / 4.33);
                    pv = (decimal)(exIntercept + exSlope * mi) / 4.33m;
                }
                else
                {
                    int mi = enm + i - 1;
                    pv = (decimal)(exIntercept + exSlope * mi);
                }
                if (pv > 0) pv = 0;
                exclProjected.Add(pv);
            }
        }

        return exclHistorical.Concat(exclProjected).ToList();
    }

    string BucketKey(DateTime d) => SelectedInterval switch
    {
        "week" => System.Globalization.ISOWeek.GetYear(d) + "-W" +
                  System.Globalization.ISOWeek.GetWeekOfYear(d).ToString("D2"),
        "year" => d.Year.ToString(),
        _ => d.ToString("yyyy-MM")
    };

    string BucketLabel(string key)
    {
        if (SelectedInterval == "week" && key.Contains("-W"))
        {
            var parts = key.Split("-W");
            return $"W{parts[1]}";
        }
        if (SelectedInterval == "year") return key;
        if (key.Length >= 7)
        {
            if (DateTime.TryParseExact(key, "yyyy-MM", System.Globalization.CultureInfo.InvariantCulture,
                System.Globalization.DateTimeStyles.None, out var dt))
                return dt.ToString("MMM yy");
        }
        return key;
    }

    static decimal NiceGridStep(decimal range, int targetLines)
    {
        if (range <= 0) return 1;
        double rough = (double)range / targetLines;
        double magnitude = Math.Pow(10, Math.Floor(Math.Log10(rough)));
        double normalized = rough / magnitude;

        double nice;
        if (normalized <= 1) nice = 1;
        else if (normalized <= 2) nice = 2;
        else if (normalized <= 2.5) nice = 2.5;
        else if (normalized <= 5) nice = 5;
        else nice = 10;

        return (decimal)(nice * magnitude);
    }

    static string FormatAmount(decimal val)
    {
        if (Math.Abs(val) >= 1000)
            return $"{val / 1000:0.#}k";
        return val.ToString("0");
    }

    string FormatAmountWithSymbol(decimal val)
    {
        var symbol = MainCurrencySymbol;
        var abs = Math.Abs(val);
        var sign = val < 0 ? "-" : "";
        if (abs >= 1000)
            return $"{sign}{symbol}{abs / 1000:0.#}k";
        return $"{sign}{symbol}{abs:0}";
    }

    static string BuildLinePath(List<(double X, double Y)> points)
    {
        if (points.Count == 0) return "";
        var sb = new System.Text.StringBuilder();
        sb.Append($"M{P(points[0].X)},{P(points[0].Y)}");
        for (int i = 1; i < points.Count; i++)
            sb.Append($" L{P(points[i].X)},{P(points[i].Y)}");
        return sb.ToString();
    }

    static string BuildAreaPath(List<(double X, double Y)> points, double baseY)
    {
        if (points.Count < 2) return "";
        var sb = new System.Text.StringBuilder();
        sb.Append($"M{P(points[0].X)},{P(baseY)}");
        foreach (var pt in points)
            sb.Append($" L{P(pt.X)},{P(pt.Y)}");
        sb.Append($" L{P(points[^1].X)},{P(baseY)} Z");
        return sb.ToString();
    }

    static string P(double v) => v.ToString("0.##", System.Globalization.CultureInfo.InvariantCulture);

    void RenderChart() { }

    (double rx, double ry, double tx, double t1y, double t2y) TooltipPos(double px, double py)
    {
        const double w = 112, h = 36, gap = 10;
        double rx = px - w / 2;
        double ry = py - h - gap;
        double tx = px;
        if (ry < 2) ry = py + gap;
        if (ry + h > ChartHeight - 2) ry = ChartHeight - h - 2;
        if (rx < 2) { tx += 2 - rx; rx = 2; }
        else if (rx + w > ChartWidth - 2) { tx -= rx + w - ChartWidth + 2; rx = ChartWidth - w - 2; }
        return (rx, ry, tx, ry + 16, ry + 29);
    }

    record AccountMeta(string Id, string Name, string Currency, string DateFormat, bool HasCustomMapping, int DateIndex, int AmountIndex, int MemoIndex, int CategoryIndex);

    List<AccountMeta> LoadAccountMetas()
    {
        var result = new List<AccountMeta>();
        var baseDir = Path.Combine(Env.ContentRootPath, "App_Data", "accounts");
        if (!Directory.Exists(baseDir)) return result;

        foreach (var dir in Directory.GetDirectories(baseDir))
        {
            var metaPath = Path.Combine(dir, "account.meta");
            if (!File.Exists(metaPath)) continue;

            var id = Path.GetFileName(dir);
            string name = id, currency = "GBP", dateFormat = "dd/MM/yyyy";
            bool hasMapping = false;
            int di = -1, ai = -1, mi = -1, ci = -1;

            foreach (var line in File.ReadAllLines(metaPath))
            {
                var sep = line.IndexOf('=');
                if (sep < 0) continue;
                var key = line[..sep].Trim();
                var val = line[(sep + 1)..].Trim();

                switch (key)
                {
                    case "name": name = val; break;
                    case "currency": currency = val; break;
                    case "dateformat": dateFormat = val; break;
                    case "hasmapping": hasMapping = val == "true"; break;
                    case "dateindex": int.TryParse(val, out di); break;
                    case "amountindex": int.TryParse(val, out ai); break;
                    case "memoindex": int.TryParse(val, out mi); break;
                    case "categoryindex": int.TryParse(val, out ci); break;
                }
            }

            result.Add(new AccountMeta(id, name, currency, dateFormat, hasMapping, di, ai, mi, ci));
        }

        return result;
    }

    void LoadTransactionsFromCsv()
    {
        AllTransactions.Clear();
        ErrorMessage = null;

        var accounts = LoadAccountMetas();

        foreach (var acct in accounts)
        {
            var dir = Path.Combine(Env.ContentRootPath, "App_Data", "accounts", acct.Id);
            if (!Directory.Exists(dir)) continue;

            foreach (var filePath in Directory.GetFiles(dir, "*.csv"))
            {
                try { ParseCsvFile(filePath, acct); }
                catch (Exception ex)
                {
                    ErrorMessage = $"Error reading {Path.GetFileName(filePath)}: {ex.Message}";
                }
            }
        }
    }

    void ParseCsvFile(string filePath, AccountMeta acct)
    {
        var lines = File.ReadAllLines(filePath);
        if (lines.Length < 2) return;

        var headerFields = ParseCsvLine(lines[0]);
        ColumnMap columnMap;

        if (acct.HasCustomMapping && (acct.DateIndex >= 0 || acct.AmountIndex >= 0))
        {
            var autoMap = DetectColumns(headerFields);
            columnMap = new ColumnMap(
                acct.DateIndex >= 0 ? acct.DateIndex : autoMap.DateIndex,
                acct.AmountIndex >= 0 ? acct.AmountIndex : autoMap.AmountIndex,
                acct.MemoIndex >= 0 ? acct.MemoIndex : autoMap.MemoIndex,
                acct.CategoryIndex >= 0 ? acct.CategoryIndex : autoMap.SubcategoryIndex
            );
        }
        else
        {
            columnMap = DetectColumns(headerFields);
        }

        if (columnMap.DateIndex < 0 || columnMap.AmountIndex < 0)
        {
            ErrorMessage = $"Could not detect Date/Amount columns in {Path.GetFileName(filePath)}";
            return;
        }

        for (var i = 1; i < lines.Length; i++)
        {
            if (string.IsNullOrWhiteSpace(lines[i])) continue;
            var tx = ParseLine(lines[i], columnMap, acct);
            if (tx is not null) AllTransactions.Add(tx);
        }
    }

    record ColumnMap(int DateIndex, int AmountIndex, int MemoIndex, int SubcategoryIndex);

    static ColumnMap DetectColumns(List<string> headers)
    {
        int dateIdx = -1, amountIdx = -1, memoIdx = -1, subcategoryIdx = -1;
        for (var i = 0; i < headers.Count; i++)
        {
            var h = headers[i].Trim().ToLowerInvariant();
            if (dateIdx < 0 && (h == "date" || h == "transaction date" || h == "trans date" || h == "posting date")) dateIdx = i;
            if (amountIdx < 0 && (h == "amount" || h == "debit" || h == "credit" || h == "value" || h == "transaction amount")) amountIdx = i;
            if (memoIdx < 0 && (h == "memo" || h == "description" || h == "narrative" || h == "details" || h == "transaction description" || h == "payee")) memoIdx = i;
            if (subcategoryIdx < 0 && (h == "subcategory" || h == "category" || h == "type")) subcategoryIdx = i;
        }
        return new ColumnMap(dateIdx, amountIdx, memoIdx, subcategoryIdx);
    }

    Tx? ParseLine(string line, ColumnMap map, AccountMeta acct)
    {
        var fields = ParseCsvLine(line);
        var maxRequired = Math.Max(map.DateIndex, Math.Max(map.AmountIndex, Math.Max(map.MemoIndex, map.SubcategoryIndex)));
        if (fields.Count <= maxRequired) return null;

        var dateStr = fields[map.DateIndex].Trim();
        if (!TryParseDate(dateStr, acct.DateFormat, out var date)) return null;

        var amountStr = fields[map.AmountIndex].Trim().Replace("$", "").Replace("£", "").Replace("€", "").Replace("¥", "").Replace(",", "");
        if (!decimal.TryParse(amountStr, out var amount)) return null;

        var memo = map.MemoIndex >= 0 && map.MemoIndex < fields.Count ? fields[map.MemoIndex].Trim() : "";
        var subcategory = map.SubcategoryIndex >= 0 && map.SubcategoryIndex < fields.Count ? fields[map.SubcategoryIndex].Trim() : "";
        var (company, paymentMethod) = ExtractCompanyAndPayment(memo);
        if (company == "Unknown" && !string.IsNullOrWhiteSpace(subcategory))
        {
            var (subCompany, _) = ExtractCompanyAndPayment(subcategory);
            if (subCompany != "Unknown") company = subCompany;
        }
        return new Tx(date, company, memo, paymentMethod, amount, acct.Currency, acct.Id, acct.Name);
    }

    static (string Company, string? PaymentMethod) ExtractCompanyAndPayment(string memo)
    {
        if (string.IsNullOrWhiteSpace(memo)) return ("Unknown", null);
        var cleaned = memo.Replace("*", " ").Replace("#", " ").Replace("  ", " ").Trim().ToUpperInvariant();
        string? paymentMethod = null; string? company = null;

        foreach (var processor in PaymentProcessors)
        {
            if (cleaned.Contains(processor, StringComparison.OrdinalIgnoreCase))
            {
                paymentMethod = FormatName(processor);
                var idx = cleaned.IndexOf(processor, StringComparison.OrdinalIgnoreCase);
                var after = cleaned[(idx + processor.Length)..].Trim();
                company = FindKnownCompany(after);
                if (company != null) return (company, paymentMethod);
                if (!string.IsNullOrWhiteSpace(after))
                {
                    var words = after.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                    if (words.Length > 0) return (FormatName(string.Join(" ", words.Take(2))), paymentMethod);
                }
            }
        }

        company = FindKnownCompany(cleaned);
        if (company != null) return (company, null);

        string[] skipPrefixes = ["CARD", "PAYMENT", "PURCHASE", "POS", "DEBIT", "CREDIT", "DIRECT", "TRANSFER", "REF", "TO", "FROM"];
        var parts = cleaned.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        var meaningful = parts.Where(p => !skipPrefixes.Contains(p) && p.Length > 2).Take(2).ToArray();
        if (meaningful.Length > 0) return (FormatName(string.Join(" ", meaningful)), null);
        return ("Unknown", null);
    }

    static string? FindKnownCompany(string text)
    {
        if (string.IsNullOrWhiteSpace(text)) return null;
        foreach (var c in KnownCompanies.OrderByDescending(c => c.Length))
            if (text.Contains(c, StringComparison.OrdinalIgnoreCase)) return FormatName(c);
        return null;
    }

    static string FormatName(string name) =>
        string.IsNullOrWhiteSpace(name) ? name :
        System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(name.ToLowerInvariant());

    static bool TryParseDate(string dateStr, string preferredFormat, out DateTime date)
    {
        if (DateTime.TryParseExact(dateStr, preferredFormat, System.Globalization.CultureInfo.InvariantCulture,
            System.Globalization.DateTimeStyles.None, out date)) return true;

        string[] fallbacks = ["dd/MM/yyyy","MM/dd/yyyy","yyyy-MM-dd","dd-MM-yyyy","MM-dd-yyyy",
            "d/M/yyyy","M/d/yyyy","dd MMM yyyy","MMM dd, yyyy"];
        if (DateTime.TryParseExact(dateStr, fallbacks, System.Globalization.CultureInfo.InvariantCulture,
            System.Globalization.DateTimeStyles.None, out date)) return true;
        return DateTime.TryParse(dateStr, out date);
    }

    static List<string> ParseCsvLine(string line)
    {
        var fields = new List<string>();
        var current = new System.Text.StringBuilder();
        var inQuotes = false;
        foreach (var c in line)
        {
            if (c == '"') inQuotes = !inQuotes;
            else if (c == ',' && !inQuotes) { fields.Add(current.ToString()); current.Clear(); }
            else current.Append(c);
        }
        fields.Add(current.ToString());
        return fields;
    }
}

<style>
    h1 {
        margin: 0
    }

    .sub {
        color: #aaa;
        margin: .3rem 0 1rem
    }

    .controls-card {
        margin-bottom: 1rem;
    }

    .controls-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        flex-wrap: wrap;
    }

    .mode-row {
        display: flex;
        align-items: center;
        gap: .5rem;
        margin-top: .75rem;
        padding-top: .75rem;
        border-top: 1px solid rgba(255,255,255,.06);
        flex-wrap: wrap;
    }

    .mode-btn svg {
        width: 14px;
        height: 14px;
        stroke: currentColor;
        fill: none;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
    }

    .mode-hint {
        font-size: .8rem;
        color: #666;
        margin-left: .25rem;
    }

    .card-head-pills {
        display: flex;
        align-items: center;
        gap: .5rem;
        flex-wrap: wrap;
    }

    .mode-pill {
        font-size: .75rem;
        padding: .12rem .5rem;
        border-radius: 999px;
    }

    .mode-pill.all {
        background: #1a1a1a;
        border: 1px solid rgba(255,255,255,.1);
        color: #ccc;
    }

    .mode-pill.smart {
        background: #1a2e1a;
        border: 1px solid rgba(92,224,122,.2);
        color: #5ce07a;
    }

    .controls-left {
        display: flex;
        align-items: center;
        gap: .5rem;
        flex-wrap: wrap;
    }

    .controls-right {
        display: flex;
        align-items: center;
        gap: .75rem;
        flex-wrap: wrap;
    }

    .interval-label {
        color: #888;
        font-size: .85rem;
        margin-right: .25rem;
    }

    .periods-input {
        width: 5.5rem;
        padding: .45rem .6rem;
        border-radius: 10px;
        background: #1a1a1a;
        border: 1px solid rgba(255,255,255,.12);
        color: #f3f3f3;
        font-size: .95rem;
        font-variant-numeric: tabular-nums;
        font-family: ui-monospace, monospace;
        outline: none;
        transition: border-color .2s ease;
        -moz-appearance: textfield;
    }

    .periods-input:focus {
        border-color: rgba(122,162,247,.5);
    }

    .periods-input::-webkit-inner-spin-button,
    .periods-input::-webkit-outer-spin-button {
        opacity: 1;
    }

    .calculate-btn {
        background: #1a1a2e !important;
        border-color: rgba(122,162,247,.25) !important;
        color: #7aa2f7 !important;
        font-weight: 500;
    }

    .calculate-btn:hover {
        background: #222244 !important;
        color: #9bb8ff !important;
    }

    .calculate-btn svg {
        width: 14px;
        height: 14px;
        stroke: currentColor;
        fill: none;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
    }

    .range-value {
        color: #ccc;
        font-size: .9rem;
        font-variant-numeric: tabular-nums;
        font-family: ui-monospace, monospace;
    }

    .card {
        background: #111;
        border: 1px solid rgba(255,255,255,.08);
        border-radius: 16px;
        padding: 1rem;
        transition: transform .2s ease;
    }

    .card:hover {
        transform: translateY(-1px)
    }

    .card.empty {
        text-align: center;
        padding: 2rem;
        color: #ccc;
    }

    .card.empty a {
        color: #7aa2f7;
        text-decoration: none;
    }

    .card.empty a:hover {
        text-decoration: underline
    }

    .chart-card {
        max-height: none;
        margin-bottom: 1rem;
    }

    .card-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: .6rem;
        color: #ddd;
    }

    .count {
        font-size: .85rem;
        padding: .15rem .5rem;
        border-radius: 999px;
        background: #1a1a1a;
        border: 1px solid rgba(255,255,255,.1);
    }

    .projection-pill {
        font-size: .8rem;
        padding: .15rem .55rem;
        border-radius: 999px;
        background: #1a1a2e;
        border: 1px solid rgba(122,162,247,.2);
        color: #7aa2f7;
    }

    .chart-area {
        width: 100%;
        overflow-x: auto;
    }

    .chart-svg {
        width: 100%;
        min-width: 500px;
        height: auto;
        display: block;
    }

    .chart-line {
        pointer-events: none;
    }

    .chart-point-group {
        pointer-events: all;
    }

    .chart-legend {
        display: flex;
        gap: 1.25rem;
        justify-content: center;
        margin-top: .75rem;
        font-size: .85rem;
        color: #aaa;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: .4rem;
        cursor: pointer;
        user-select: none;
        transition: opacity .2s ease;
    }

    .legend-item.inactive {
        opacity: .4;
    }

    .legend-dot.inactive {
        opacity: .4;
    }

    .legend-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-block;
    }

    .historical-dot {
        background: #e05c5c
    }

    .projected-dot {
        background: #7aa2f7
    }

    .error-banner {
        background: rgba(224,92,92,.15);
        border: 1px solid rgba(224,92,92,.3);
        border-radius: 12px;
        padding: .75rem 1rem;
        margin-bottom: 1rem;
        color: #eaa;
    }

    .tool {
        display: inline-flex;
        align-items: center;
        gap: .4rem;
        padding: .45rem .7rem;
        border-radius: 12px;
        background: #141414;
        border: 1px solid rgba(255,255,255,.08);
        color: #ccc;
        cursor: pointer;
        transition: background .2s ease,transform .2s ease,border .2s ease,color .2s ease;
    }

    .tool:hover {
        background: #1c1c1c;
        transform: translateY(-1px);
        color: #fff;
    }

    .tool.active {
        background: #1f1f1f;
        border-color: rgba(255,255,255,.18);
        color: #fff;
    }

    .filter-card {
        max-height: 50vh;
        overflow: auto;
        margin-top: 1rem;
    }

    .filter-actions {
        display: flex;
        gap: .4rem;
        margin-bottom: .6rem;
    }

    .filter-btn {
        padding: .3rem .6rem;
        border-radius: 10px;
        background: #1a1a1a;
        border: 1px solid rgba(255,255,255,.08);
        color: #ccc;
        cursor: pointer;
        font-size: .8rem;
        transition: background .2s ease, color .2s ease;
    }

    .filter-btn:hover {
        background: #222;
        color: #fff;
    }

    .company-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
        gap: .35rem;
    }

    .company-item {
        display: flex;
        align-items: center;
        gap: .5rem;
        padding: .5rem .6rem;
        border-radius: 10px;
        background: #151515;
        border: 1px solid rgba(255,255,255,.06);
        cursor: pointer;
        transition: background .2s ease, border-color .2s ease, opacity .2s ease;
        user-select: none;
    }

    .company-item:hover {
        background: #1c1c1c;
    }

    .company-item:not(.selected) {
        opacity: .5;
    }

    .company-item.selected {
        border-color: rgba(255,255,255,.12);
    }

    .check-box {
        width: 18px;
        height: 18px;
        border-radius: 5px;
        border: 1px solid rgba(255,255,255,.15);
        background: #1a1a1a;
        display: flex;
        align-items: center;
        justify-content: center;
        flex: 0 0 auto;
        transition: background .2s ease, border-color .2s ease;
    }

    .company-item.selected .check-box {
        background: #7aa2f7;
        border-color: #7aa2f7;
    }

    .check-box svg {
        width: 12px;
        height: 12px;
        stroke: #fff;
        fill: none;
        stroke-width: 2.5;
        stroke-linecap: round;
        stroke-linejoin: round;
    }

    .company-name {
        flex: 1 1 auto;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-size: .85rem;
        color: #eaeaea;
    }

    .company-amount {
        flex: 0 0 auto;
        font-size: .8rem;
        font-variant-numeric: tabular-nums;
        font-family: ui-monospace, monospace;
    }

    .pill {
        display: inline-block;
        padding: .15rem .55rem;
        border-radius: 999px;
        background: #1a1a1a;
        border: 1px solid rgba(255,255,255,.08);
        color: #f3f3f3;
    }

    .muted {
        color: #999
    }

    .negative {
        color: #e05c5c !important
    }

    .positive {
        color: #5ce07a !important
    }

    .summary-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: .75rem;
        margin-bottom: 1rem;
    }

    @@media (max-width: 768px) {
        .summary-grid {
            grid-template-columns: repeat(2, 1fr)
        }

        .controls-row {
            flex-direction: column;
            align-items: flex-start;
        }
    }

    .summary-card {
        display: flex;
        flex-direction: column;
        gap: .25rem;
        padding: .75rem 1rem;
        background: #111;
        border: 1px solid rgba(255,255,255,.08);
        border-radius: 12px;
    }

    .summary-card.muted-card {
        background: #0d0d0d
    }

    .summary-label {
        font-size: .8rem;
        color: #888;
        text-transform: uppercase;
        letter-spacing: .03em;
    }

    .summary-value {
        font-size: 1.25rem;
        font-weight: 600;
        font-variant-numeric: tabular-nums;
        font-family: ui-monospace, monospace;
    }

    .summary-value.muted {
        color: #ccc
    }

    .profile-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: 1px solid rgba(255,255,255,.08);
        border-radius: 8px;
        padding: .3rem;
        cursor: pointer;
        transition: background .2s ease, border-color .2s ease;
        flex: 0 0 auto;
    }

    .profile-btn:hover {
        background: rgba(122,162,247,.15);
        border-color: rgba(122,162,247,.3);
    }

    .profile-btn svg {
        width: 14px;
        height: 14px;
        stroke: #7aa2f7;
        fill: none;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
    }

    .cancel-badge {
        font-size: .7rem;
        padding: .1rem .4rem;
        border-radius: 999px;
        background: rgba(224,92,92,.15);
        border: 1px solid rgba(224,92,92,.25);
        color: #e05c5c;
        white-space: nowrap;
        flex: 0 0 auto;
    }

    .exclusion-dot {
        background: #e0a93e;
    }

    .sub-indicator {
        color: #5ce07a;
        font-size: .6rem;
        margin-left: .25rem;
        vertical-align: middle;
    }

    .mode-pill.subonly {
        background: #2e2a1a;
        border: 1px solid rgba(224,169,62,.2);
        color: #e0a93e;
    }

    .profile-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.6);
        z-index: 200;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 2rem;
        overflow: auto;
    }

    .profile-panel {
        width: 100%;
        max-width: 800px;
        background: #0f0f0f;
        border: 1px solid rgba(255,255,255,.1);
        border-radius: 18px;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .profile-header {
        display: flex;
        align-items: center;
        gap: .75rem;
        flex-wrap: wrap;
    }

    .back-btn {
        display: inline-flex;
        align-items: center;
        gap: .4rem;
        padding: .45rem .75rem;
        border-radius: 12px;
        background: #141414;
        border: 1px solid rgba(255,255,255,.08);
        color: #ccc;
        cursor: pointer;
        transition: background .2s ease, transform .2s ease, color .2s ease;
        font-size: .9rem;
    }

    .back-btn svg {
        width: 16px;
        height: 16px;
        stroke: currentColor;
        fill: none;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
    }

    .back-btn:hover {
        background: #1c1c1c;
        color: #fff;
        transform: translateY(-1px);
    }

    .profile-title {
        font-size: 1.15rem;
        font-weight: 600;
        color: #fff;
    }

    .behavior-pill {
        font-size: .75rem;
        padding: .15rem .55rem;
        border-radius: 999px;
    }

    .behavior-pill.activesubscription {
        background: #1a2e1a;
        border: 1px solid rgba(92,224,122,.2);
        color: #5ce07a;
    }

    .behavior-pill.recurringreturner {
        background: #2e2a1a;
        border: 1px solid rgba(224,200,92,.2);
        color: #e0c85c;
    }

    .behavior-pill.cancelledsubscription {
        background: #2e1a1a;
        border: 1px solid rgba(224,92,92,.2);
        color: #e05c5c;
    }

    .behavior-pill.oneoff, .behavior-pill.irregular {
        background: #1a1a1a;
        border: 1px solid rgba(255,255,255,.1);
        color: #999;
    }

    .profile-stats {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: .75rem;
    }

    @@media (max-width: 600px) {
        .profile-stats {
            grid-template-columns: repeat(2, 1fr);
        }
    }

    .stat-card {
        display: flex;
        flex-direction: column;
        gap: .25rem;
        padding: .75rem 1rem;
        background: #111;
        border: 1px solid rgba(255,255,255,.08);
        border-radius: 12px;
    }

    .stat-label {
        font-size: .8rem;
        color: #888;
        text-transform: uppercase;
        letter-spacing: .03em;
    }

    .stat-value {
        font-size: 1.15rem;
        font-weight: 600;
        font-variant-numeric: tabular-nums;
        font-family: ui-monospace, monospace;
        color: #f3f3f3;
    }

    .cancel-card {
        background: #111;
    }

    .cancel-info {
        display: flex;
        align-items: center;
        gap: .75rem;
        color: #e05c5c;
        font-size: .9rem;
        flex-wrap: wrap;
    }

    .cancel-remove {
        color: #e05c5c !important;
        border-color: rgba(224,92,92,.2) !important;
    }

    .cancel-remove:hover {
        background: rgba(224,92,92,.15) !important;
    }

    .cancel-form {
        display: flex;
        flex-direction: column;
        gap: .6rem;
    }

    .cancel-label {
        font-size: .85rem;
        color: #aaa;
    }

    .cancel-input-row {
        display: flex;
        align-items: center;
        gap: .75rem;
        flex-wrap: wrap;
    }

    .cancel-date-input {
        padding: .45rem .6rem;
        border-radius: 10px;
        background: #1a1a1a;
        border: 1px solid rgba(255,255,255,.12);
        color: #f3f3f3;
        font-size: .9rem;
        outline: none;
        transition: border-color .2s ease;
        color-scheme: dark;
    }

    .cancel-date-input:focus {
        border-color: rgba(122,162,247,.5);
    }

    .profile-tx-card {
        max-height: 40vh;
        overflow: auto;
    }

    .table-container {
        width: 100%;
        overflow-x: auto;
    }

    .profile-panel table {
        width: 100%;
        border-collapse: collapse;
        min-width: 480px;
    }

    .profile-panel th, .profile-panel td {
        padding: .6rem;
        border-bottom: 1px solid rgba(255,255,255,.06);
    }

    .profile-panel th {
        text-align: left;
        color: #bbb;
        font-size: .85rem;
    }

    .profile-panel tbody tr:hover td {
        background: #1a1a1a;
    }

    .profile-panel .mono {
        color: #e0e0e0;
    }

    .profile-panel .muted {
        color: #bbb;
    }

    .pill.payment {
        background: #1a1a2e;
        border-color: rgba(122,162,247,.2);
        color: #7aa2f7;
        font-size: .85em;
    }

    .positive {
        color: #5ce07a !important;
    }
</style>
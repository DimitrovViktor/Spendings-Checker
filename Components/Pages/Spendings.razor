@page "/spendings"
@rendermode InteractiveServer
@inject IWebHostEnvironment Env

<h1>Spendings</h1>
<p class="sub">All imported transactions</p>

<div class="toolbar">
    <button class="tool @(SortBy == "date" ? "active" : "")" @onclick="SortByDate">
        <svg viewBox="0 0 24 24"><path d="M6 3v18M6 21l-3-3M6 21l3-3M18 3v18M18 3l3 3M18 3l-3 3" /></svg>
        Date
    </button>

    <button class="tool @(SortBy == "company" ? "active" : "")" @onclick="SortByCompany">
        <svg viewBox="0 0 24 24"><path d="M4 6h16M4 12h10M4 18h7" /></svg>
        Company
    </button>

    <button class="tool @(SortBy == "amount" ? "active" : "")" @onclick="SortByAmount">
        <svg viewBox="0 0 24 24"><path d="M12 3v18M8 7h8M8 17h8" /></svg>
        Amount
    </button>

    <button class="tool" @onclick="RefreshData">
        <svg viewBox="0 0 24 24"><path d="M21 12a9 9 0 1 1-9-9M21 3v6h-6" /></svg>
        Refresh
    </button>
</div>

@if (AccountNames.Count > 1)
{
    <div class="filter-bar">
        <span class="filter-label">Account</span>
        <button class="tool @(FilterAccount == null ? "active" : "")" @onclick="() => SetAccountFilter(null)">All</button>
        @foreach (var acct in AccountNames)
        {
            <button class="tool @(FilterAccount == acct.Key ? "active" : "")" @onclick="() => SetAccountFilter(acct.Key)">
                @acct.Value
                <span class="currency-tag">@AccountCurrencies.GetValueOrDefault(acct.Key, "")</span>
            </button>
        }
    </div>
}

@if (!string.IsNullOrWhiteSpace(ErrorMessage))
{
    <div class="error-banner">@ErrorMessage</div>
}

@if (Data.Count == 0)
{
    <div class="card empty">
        <p>No transactions found.</p>
        <p class="muted">Upload CSV files on the <a href="/">Home</a> page to see your spendings.</p>
    </div>
}
else
{
    <div class="card">
        <table>
            <thead>
                <tr>
                    <th>Date</th>
                    <th>Company</th>
                    <th>Description</th>
                    <th>Payment</th>
                    <th>Account</th>
                    <th class="r">Amount</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var t in Sorted)
                {
                    <tr>
                        <td class="mono">@t.Date.ToString("yyyy-MM-dd")</td>
                        <td><span class="pill">@t.Company</span></td>
                        <td class="muted">@t.Description</td>
                        <td>
                            @if (!string.IsNullOrWhiteSpace(t.PaymentMethod))
                            {
                                <span class="pill payment">@t.PaymentMethod</span>
                            }
                        </td>
                        <td>
                            <span class="pill account-pill">@t.AccountName</span>
                        </td>
                        <td class="r mono @(t.Amount < 0 ? "negative" : "positive")">@FormatConverted(t.Amount, t.Currency)</td>
                    </tr>
                }
            </tbody>
        </table>
    </div>

    <div class="summary-grid">
        @{
            var allFiltered = FilteredData.ToList();
            var spending = allFiltered.Where(x => x.Amount < 0).Sum(x => ConvertToMain(x.Amount, x.Currency));
            var earnings = allFiltered.Where(x => x.Amount > 0).Sum(x => ConvertToMain(x.Amount, x.Currency));
            var total = allFiltered.Sum(x => ConvertToMain(x.Amount, x.Currency));
        }
        <div class="summary-card">
            <span class="summary-label">Spendings (@MainCurrency)</span>
            <span class="summary-value negative">@FormatConverted(spending, MainCurrency)</span>
        </div>
        <div class="summary-card">
            <span class="summary-label">Earnings (@MainCurrency)</span>
            <span class="summary-value positive">+@FormatConverted(earnings, MainCurrency)</span>
        </div>
        <div class="summary-card">
            <span class="summary-label">Total (@MainCurrency)</span>
            <span class="summary-value @(total < 0 ? "negative" : "positive")">@FormatConverted(total, MainCurrency)</span>
        </div>
        <div class="summary-card muted-card">
            <span class="summary-label">Transactions</span>
            <span class="summary-value muted">@allFiltered.Count</span>
        </div>
    </div>
}

@code {
    record Tx(DateTime Date, string Company, string Description, string? PaymentMethod, decimal Amount, string Currency, string AccountId, string AccountName);

    readonly List<Tx> Data = new();

    string SortBy = "date";
    bool Asc = false;
    string? ErrorMessage;
    string? FilterAccount;

    readonly Dictionary<string, string> AccountNames = new();
    readonly Dictionary<string, string> AccountCurrencies = new();

    string MainCurrency = "EUR";
    readonly Dictionary<string, decimal> CurrencyRates = new()
    {
        ["EUR"] = 1m, ["GBP"] = 1.18m, ["USD"] = 0.92m, ["JPY"] = 0.006m, ["CHF"] = 1.06m
    };

    static readonly Dictionary<string, string> CurrencySymbolMap = new()
    {
        ["GBP"] = "£", ["USD"] = "$", ["EUR"] = "€", ["JPY"] = "¥", ["CHF"] = "CHF "
    };

    string MainCurrencySymbol => CurrencySymbolMap.GetValueOrDefault(MainCurrency, "");

    string FormatConverted(decimal amount, string fromCurrency)
    {
        var converted = ConvertToMain(amount, fromCurrency);
        var symbol = MainCurrencySymbol;
        var abs = Math.Abs(converted).ToString("0.00");
        return converted < 0 ? $"-{symbol}{abs}" : $"{symbol}{abs}";
    }

    decimal ConvertToMain(decimal amount, string fromCurrency)
    {
        if (fromCurrency == MainCurrency) return amount;
        var fromRate = CurrencyRates.GetValueOrDefault(fromCurrency, 1m);
        var mainRate = CurrencyRates.GetValueOrDefault(MainCurrency, 1m);
        if (mainRate == 0) mainRate = 1m;
        return amount * fromRate / mainRate;
    }

    IEnumerable<Tx> FilteredData => FilterAccount is null ? Data : Data.Where(x => x.AccountId == FilterAccount);

    IEnumerable<Tx> Sorted
    {
        get
        {
            var source = FilteredData;
            return SortBy switch
            {
                "company" => Asc ? source.OrderBy(x => x.Company) : source.OrderByDescending(x => x.Company),
                "amount" => Asc ? source.OrderBy(x => x.Amount) : source.OrderByDescending(x => x.Amount),
                _ => Asc ? source.OrderBy(x => x.Date) : source.OrderByDescending(x => x.Date)
            };
        }
    }

    static readonly HashSet<string> PaymentProcessors = new(StringComparer.OrdinalIgnoreCase)
    {
        "PAYPAL","STRIPE","SQUARE","KLARNA","AFTERPAY","CLEARPAY","VENMO",
        "APPLE PAY","APPLEPAY","GOOGLE PAY","GOOGLEPAY","SAMSUNG PAY",
        "VISA","MASTERCARD","AMEX","AMERICAN EXPRESS",
        "REVOLUT","WISE","TRANSFERWISE","SKRILL","NETELLER",
        "CASH APP","CASHAPP","ZELLE","WORLDPAY","ADYEN","CHECKOUT"
    };

    static readonly HashSet<string> KnownCompanies = new(StringComparer.OrdinalIgnoreCase)
    {
        "NETFLIX","SPOTIFY","APPLE","APPLE MUSIC","YOUTUBE","YOUTUBE PREMIUM",
        "DISNEY","DISNEY+","DISNEYPLUS","HBO","HBO MAX","HULU","PRIME VIDEO",
        "AMAZON PRIME","PARAMOUNT","PEACOCK","CRUNCHYROLL","TWITCH","DAZN",
        "AMAZON","EBAY","ETSY","ALIEXPRESS","ALIBABA","WISH","SHEIN",
        "WALMART","TARGET","COSTCO","IKEA","WAYFAIR","BEST BUY","BESTBUY",
        "HOME DEPOT","LOWES","MACYS","NORDSTROM","ZARA","H&M","HM",
        "UNIQLO","GAP","ASOS","BOOHOO","PRIMARK","NEXT","MARKS SPENCER",
        "TESCO","SAINSBURYS","ASDA","MORRISONS","ALDI","LIDL","WAITROSE",
        "ARGOS","CURRYS","JOHN LEWIS","BOOTS","SUPERDRUG",
        "UBER EATS","UBEREATS","DELIVEROO","DOORDASH","GRUBHUB","JUST EAT",
        "JUSTEAT","POSTMATES","INSTACART","GOPUFF",
        "MCDONALDS","BURGER KING","WENDYS","KFC","SUBWAY","DOMINOS",
        "PIZZA HUT","PAPA JOHNS","CHIPOTLE","TACO BELL","FIVE GUYS",
        "NANDOS","GREGGS","PRET","PRET A MANGER","COSTA","STARBUCKS",
        "DUNKIN","TIM HORTONS","KRISPY KREME",
        "GOOGLE","MICROSOFT","ADOBE","DROPBOX","SLACK","ZOOM","NOTION",
        "GITHUB","GITLAB","ATLASSIAN","JIRA","CONFLUENCE","TRELLO",
        "CANVA","FIGMA","SKETCH","INVISION","MIRO",
        "OPENAI","CHATGPT","MIDJOURNEY","ANTHROPIC",
        "AWS","AZURE","DIGITALOCEAN","HEROKU","VERCEL","NETLIFY",
        "GODADDY","NAMECHEAP","CLOUDFLARE","SQUARESPACE","WIX","SHOPIFY",
        "WORDPRESS","HOSTINGER","BLUEHOST","SITEGROUND",
        "STEAM","XBOX","PLAYSTATION","NINTENDO","EPIC GAMES","EPICGAMES",
        "RIOT GAMES","RIOTGAMES","BLIZZARD","EA","ELECTRONIC ARTS","UBISOFT",
        "ROBLOX","MOJANG","MINECRAFT",
        "COURSERA","UDEMY","SKILLSHARE","MASTERCLASS","LINKEDIN LEARNING",
        "PLURALSIGHT","CODECADEMY","TREEHOUSE","BRILLIANT","DUOLINGO",
        "AUDIBLE","KINDLE","SCRIBD","BLINKIST",
        "UBER","LYFT","BOLT","GRAB","DIDI","CABIFY","FREENOW",
        "AIRBNB","BOOKING","BOOKING.COM","EXPEDIA","HOTELS.COM","TRIVAGO",
        "SKYSCANNER","KAYAK","TRAINLINE","NATIONAL RAIL","TFL",
        "RYANAIR","EASYJET","BRITISH AIRWAYS","DELTA","UNITED","SOUTHWEST",
        "HERTZ","AVIS","ENTERPRISE","SIXT","EUROPCAR",
        "PELOTON","STRAVA","MYFITNESSPAL","HEADSPACE","CALM","FITBIT",
        "NIKE","ADIDAS","UNDER ARMOUR","PUMA","REEBOK","GYM","PUREGYM",
        "DAVID LLOYD","VIRGIN ACTIVE","ANYTIME FITNESS","PLANET FITNESS",
        "PATREON","ONLYFANS","SUBSTACK","MEDIUM","GUMROAD",
        "EXPERIAN","EQUIFAX","CREDIT KARMA","CLEARSCORE",
        "VODAFONE","EE","O2","THREE","BT","SKY","VIRGIN MEDIA",
        "VERIZON","ATT","T-MOBILE","SPRINT","COMCAST","XFINITY",
        "BRITISH GAS","OCTOPUS ENERGY","BULB","EON","EDF","SSE","SCOTTISH POWER"
    };

    protected override void OnInitialized()
    {
        LoadCurrencySettings();
        LoadTransactionsFromAccounts();
    }

    void LoadCurrencySettings()
    {
        var settingsPath = Path.Combine(Env.ContentRootPath, "App_Data", "settings.meta");
        if (!File.Exists(settingsPath)) return;

        foreach (var line in File.ReadAllLines(settingsPath))
        {
            var sep = line.IndexOf('=');
            if (sep < 0) continue;
            var key = line[..sep].Trim();
            var val = line[(sep + 1)..].Trim();

            if (key == "maincurrency")
            {
                MainCurrency = val;
            }
            else if (key.StartsWith("rate_"))
            {
                var cur = key[5..];
                if (decimal.TryParse(val, System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out var rate))
                {
                    CurrencyRates[cur] = rate;
                }
            }
        }
    }

    void RefreshData() => LoadTransactionsFromAccounts();

    void SetAccountFilter(string? accountId)
    {
        FilterAccount = accountId;
    }

    record AccountMeta(string Id, string Name, string Currency, string DateFormat, bool HasCustomMapping, int DateIndex, int AmountIndex, int MemoIndex, int CategoryIndex);

    List<AccountMeta> LoadAccountMetas()
    {
        var result = new List<AccountMeta>();
        var baseDir = Path.Combine(Env.ContentRootPath, "App_Data", "accounts");
        if (!Directory.Exists(baseDir)) return result;

        foreach (var dir in Directory.GetDirectories(baseDir))
        {
            var metaPath = Path.Combine(dir, "account.meta");
            if (!File.Exists(metaPath)) continue;

            var id = Path.GetFileName(dir);
            string name = id, currency = "GBP", dateFormat = "dd/MM/yyyy";
            bool hasMapping = false;
            int di = -1, ai = -1, mi = -1, ci = -1;

            foreach (var line in File.ReadAllLines(metaPath))
            {
                var sep = line.IndexOf('=');
                if (sep < 0) continue;
                var key = line[..sep].Trim();
                var val = line[(sep + 1)..].Trim();

                switch (key)
                {
                    case "name": name = val; break;
                    case "currency": currency = val; break;
                    case "dateformat": dateFormat = val; break;
                    case "hasmapping": hasMapping = val == "true"; break;
                    case "dateindex": int.TryParse(val, out di); break;
                    case "amountindex": int.TryParse(val, out ai); break;
                    case "memoindex": int.TryParse(val, out mi); break;
                    case "categoryindex": int.TryParse(val, out ci); break;
                }
            }

            result.Add(new AccountMeta(id, name, currency, dateFormat, hasMapping, di, ai, mi, ci));
        }

        return result;
    }

    void LoadTransactionsFromAccounts()
    {
        Data.Clear();
        AccountNames.Clear();
        AccountCurrencies.Clear();
        ErrorMessage = null;

        var accounts = LoadAccountMetas();

        foreach (var acct in accounts)
        {
            AccountNames[acct.Id] = acct.Name;
            AccountCurrencies[acct.Id] = acct.Currency;

            var dir = Path.Combine(Env.ContentRootPath, "App_Data", "accounts", acct.Id);
            if (!Directory.Exists(dir)) continue;

            foreach (var filePath in Directory.GetFiles(dir, "*.csv"))
            {
                try
                {
                    ParseCsvFile(filePath, acct);
                }
                catch (Exception ex)
                {
                    ErrorMessage = $"Error reading {Path.GetFileName(filePath)}: {ex.Message}";
                }
            }
        }
    }

    record ColumnMap(int DateIndex, int AmountIndex, int MemoIndex, int SubcategoryIndex);

    void ParseCsvFile(string filePath, AccountMeta acct)
    {
        var lines = File.ReadAllLines(filePath);
        if (lines.Length < 2) return;

        var headerFields = ParseCsvLine(lines[0]);
        ColumnMap columnMap;

        if (acct.HasCustomMapping && (acct.DateIndex >= 0 || acct.AmountIndex >= 0))
        {
            columnMap = new ColumnMap(
                acct.DateIndex >= 0 ? acct.DateIndex : DetectColumns(headerFields).DateIndex,
                acct.AmountIndex >= 0 ? acct.AmountIndex : DetectColumns(headerFields).AmountIndex,
                acct.MemoIndex >= 0 ? acct.MemoIndex : DetectColumns(headerFields).MemoIndex,
                acct.CategoryIndex >= 0 ? acct.CategoryIndex : DetectColumns(headerFields).SubcategoryIndex
            );
        }
        else
        {
            columnMap = DetectColumns(headerFields);
        }

        if (columnMap.DateIndex < 0 || columnMap.AmountIndex < 0)
        {
            ErrorMessage = $"Could not detect Date/Amount columns in {Path.GetFileName(filePath)}";
            return;
        }

        for (var i = 1; i < lines.Length; i++)
        {
            if (string.IsNullOrWhiteSpace(lines[i])) continue;
            var tx = ParseLine(lines[i], columnMap, acct);
            if (tx is not null) Data.Add(tx);
        }
    }

    static ColumnMap DetectColumns(List<string> headers)
    {
        int dateIdx = -1, amountIdx = -1, memoIdx = -1, subcategoryIdx = -1;
        for (var i = 0; i < headers.Count; i++)
        {
            var h = headers[i].Trim().ToLowerInvariant();
            if (dateIdx < 0 && (h == "date" || h == "transaction date" || h == "trans date" || h == "posting date")) dateIdx = i;
            if (amountIdx < 0 && (h == "amount" || h == "debit" || h == "credit" || h == "value" || h == "transaction amount")) amountIdx = i;
            if (memoIdx < 0 && (h == "memo" || h == "description" || h == "narrative" || h == "details" || h == "transaction description" || h == "payee")) memoIdx = i;
            if (subcategoryIdx < 0 && (h == "subcategory" || h == "category" || h == "type")) subcategoryIdx = i;
        }
        return new ColumnMap(dateIdx, amountIdx, memoIdx, subcategoryIdx);
    }

    Tx? ParseLine(string line, ColumnMap map, AccountMeta acct)
    {
        var fields = ParseCsvLine(line);
        var maxRequired = Math.Max(map.DateIndex, Math.Max(map.AmountIndex, Math.Max(map.MemoIndex, map.SubcategoryIndex)));
        if (fields.Count <= maxRequired) return null;

        var dateStr = fields[map.DateIndex].Trim();
        if (!TryParseDate(dateStr, acct.DateFormat, out var date)) return null;

        var amountStr = fields[map.AmountIndex].Trim()
            .Replace("$", "").Replace("£", "").Replace("€", "")
            .Replace("¥", "").Replace(",", "");
        if (!decimal.TryParse(amountStr, out var amount)) return null;

        var memo = map.MemoIndex >= 0 && map.MemoIndex < fields.Count ? fields[map.MemoIndex].Trim() : "";
        var subcategory = map.SubcategoryIndex >= 0 && map.SubcategoryIndex < fields.Count ? fields[map.SubcategoryIndex].Trim() : "";

        var (company, paymentMethod) = ExtractCompanyAndPayment(memo);
        if (company == "Unknown" && !string.IsNullOrWhiteSpace(subcategory))
        {
            var (subCompany, _) = ExtractCompanyAndPayment(subcategory);
            if (subCompany != "Unknown") company = subCompany;
        }

        return new Tx(date, company, memo, paymentMethod, amount, acct.Currency, acct.Id, acct.Name);
    }

    static bool TryParseDate(string dateStr, string preferredFormat, out DateTime date)
    {
        if (DateTime.TryParseExact(dateStr, preferredFormat, System.Globalization.CultureInfo.InvariantCulture,
            System.Globalization.DateTimeStyles.None, out date))
            return true;

        string[] fallbacks = ["dd/MM/yyyy","MM/dd/yyyy","yyyy-MM-dd","dd-MM-yyyy","MM-dd-yyyy",
            "d/M/yyyy","M/d/yyyy","dd MMM yyyy","MMM dd, yyyy"];

        if (DateTime.TryParseExact(dateStr, fallbacks, System.Globalization.CultureInfo.InvariantCulture,
            System.Globalization.DateTimeStyles.None, out date))
            return true;

        return DateTime.TryParse(dateStr, out date);
    }

    static (string Company, string? PaymentMethod) ExtractCompanyAndPayment(string memo)
    {
        if (string.IsNullOrWhiteSpace(memo)) return ("Unknown", null);
        var cleaned = memo.Replace("*", " ").Replace("#", " ").Replace("  ", " ").Trim().ToUpperInvariant();
        string? paymentMethod = null; string? company = null;

        foreach (var processor in PaymentProcessors)
        {
            if (cleaned.Contains(processor, StringComparison.OrdinalIgnoreCase))
            {
                paymentMethod = FormatName(processor);
                var idx = cleaned.IndexOf(processor, StringComparison.OrdinalIgnoreCase);
                var after = cleaned[(idx + processor.Length)..].Trim();
                company = FindKnownCompany(after);
                if (company != null) return (company, paymentMethod);
                if (!string.IsNullOrWhiteSpace(after))
                {
                    var words = after.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                    if (words.Length > 0) return (FormatName(string.Join(" ", words.Take(2))), paymentMethod);
                }
            }
        }

        company = FindKnownCompany(cleaned);
        if (company != null) return (company, null);

        string[] skipPrefixes = ["CARD","PAYMENT","PURCHASE","POS","DEBIT","CREDIT","DIRECT","TRANSFER","REF","TO","FROM"];
        var parts = cleaned.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        var meaningful = parts.Where(p => !skipPrefixes.Contains(p) && p.Length > 2).Take(2).ToArray();
        if (meaningful.Length > 0) return (FormatName(string.Join(" ", meaningful)), null);
        return ("Unknown", null);
    }

    static string? FindKnownCompany(string text)
    {
        if (string.IsNullOrWhiteSpace(text)) return null;
        foreach (var c in KnownCompanies.OrderByDescending(c => c.Length))
            if (text.Contains(c, StringComparison.OrdinalIgnoreCase)) return FormatName(c);
        return null;
    }

    static string FormatName(string name) =>
        string.IsNullOrWhiteSpace(name) ? name :
        System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(name.ToLowerInvariant());

    static List<string> ParseCsvLine(string line)
    {
        var fields = new List<string>();
        var current = new System.Text.StringBuilder();
        var inQuotes = false;
        foreach (var c in line)
        {
            if (c == '"') inQuotes = !inQuotes;
            else if (c == ',' && !inQuotes) { fields.Add(current.ToString()); current.Clear(); }
            else current.Append(c);
        }
        fields.Add(current.ToString());
        return fields;
    }

    void ToggleOrSet(string key)
    {
        if (SortBy == key) Asc = !Asc;
        else { SortBy = key; Asc = key == "date" ? false : true; }
    }

    void SortByDate() => ToggleOrSet("date");
    void SortByCompany() => ToggleOrSet("company");
    void SortByAmount() => ToggleOrSet("amount");
}

<style>
    .sub { color: #aaa; margin: .3rem 0 1rem }

    .toolbar {
        display: flex; gap: .5rem;
        margin-bottom: 1rem; flex-wrap: wrap;
    }

    .filter-bar {
        display: flex; gap: .5rem; align-items: center;
        margin-bottom: 1rem; flex-wrap: wrap;
    }

    .filter-label { color: #888; font-size: .85rem; margin-right: .25rem }

    .currency-tag {
        font-size: .75rem;
        padding: .05rem .35rem;
        border-radius: 999px;
        background: #1a2e1a;
        border: 1px solid rgba(92,224,122,.2);
        color: #5ce07a;
        margin-left: .25rem;
    }

    .tool {
        display: inline-flex; align-items: center; gap: .4rem;
        padding: .45rem .7rem; border-radius: 12px;
        background: #141414; border: 1px solid rgba(255,255,255,.08);
        color: #ccc; cursor: pointer;
        transition: background .2s ease,transform .2s ease,border .2s ease,color .2s ease;
    }

    .tool svg {
        width: 16px; height: 16px;
        stroke: currentColor; fill: none;
        stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;
    }

    .tool:hover { background: #1c1c1c; transform: translateY(-1px); color: #fff }

    .tool.active { background: #1f1f1f; border-color: rgba(255,255,255,.18); color: #fff }

    .card {
        background: #111; border: 1px solid rgba(255,255,255,.08);
        border-radius: 16px; padding: 1rem;
        transition: transform .2s ease;
        max-height: 60vh; overflow: auto;
    }

    .card.empty { text-align: center; padding: 2rem; color: #ccc }
    .card.empty a { color: #7aa2f7; text-decoration: none }
    .card.empty a:hover { text-decoration: underline }

    .error-banner {
        background: rgba(224,92,92,.15); border: 1px solid rgba(224,92,92,.3);
        border-radius: 12px; padding: .75rem 1rem;
        margin-bottom: 1rem; color: #eaa;
    }

    .summary-grid {
        display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: .75rem; margin-top: 1rem;
    }

    .summary-card {
        display: flex; flex-direction: column; gap: .25rem;
        padding: .75rem 1rem; background: #111;
        border: 1px solid rgba(255,255,255,.08); border-radius: 12px;
    }

    .summary-card.muted-card { background: #0d0d0d }

    .summary-label {
        font-size: .8rem; color: #888;
        text-transform: uppercase; letter-spacing: .03em;
    }

    .summary-value {
        font-size: 1.25rem; font-weight: 600;
        font-variant-numeric: tabular-nums;
        font-family: ui-monospace, monospace;
    }

    .summary-value.muted { color: #ccc }

    table { width: 100%; border-collapse: collapse; min-width: 900px }
    th, td { padding: .8rem; border-bottom: 1px solid rgba(255,255,255,.06) }
    th { text-align: left; background: #151515; color: #f3f3f3 }
    tr:hover td { background: #1a1a1a }
    .muted { color: #999 }
    .r { text-align: right }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace,monospace }

    .pill {
        display: inline-block; padding: .15rem .55rem;
        border-radius: 999px; background: #1a1a1a;
        border: 1px solid rgba(255,255,255,.08); color: #f3f3f3;
    }

    .pill.payment {
        background: #1a1a2e; border-color: rgba(122,162,247,.2);
        color: #7aa2f7; font-size: .85em;
    }

    .pill.account-pill {
        background: #1a1a1a; border-color: rgba(255,255,255,.1);
        color: #ccc; font-size: .8em;
    }

    td.mono, .r.mono { color: #f3f3f3 !important }
    .negative { color: #e05c5c !important }
    .positive { color: #5ce07a !important }
</style>
